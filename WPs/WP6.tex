\addtocounter{wpno}{1}
\begin{Workpackage}{\thewpno}
\wplabel{wp:methodology}
\WPTitle{\wpname{\thewpno}}
\WPStart{Month 1}
\WPParticipant{UCM}{32}
\WPParticipant{USTAN}{10}
\WPParticipant{SOPRA}{10}
\WPParticipant{COGNI}{5}
\WPParticipant{FRQ}{5}
\WPParticipant{UOD}{4}
\WPParticipant{IBM}{3}
\WPParticipant{YAG}{3}
\WPParticipant{SCCH}{1}



\begin{WPObjectives}
The objectives of \theWP{} are to:
\begin{compactitem}
\item Develop new refactorings that repair security vulnerabilities.
\item Develop new refactorings that rewrite source-code so that it conforms to a security-aware coding standard.
\item Develop new refactorings that introduce security-aware patterns into the source-code.
\item Develop new security-aware patterns.
\item Develop a new security-aware software engineering methodology for the development of secure big-data applications.
\item Develop a new C++ coding standard for the development of security-aware big-data applications.


\end{compactitem}
\end{WPObjectives}

\begin{WPDescription}
This workpackage will investigate new software engineering techniques and tools for the development of security-aware big-data applications. We will develop new end-user refactoring tool support in \ref{task:refactoring}; new security-aware software development patterns in \ref{task:patterns}, that will be provided to the user in the form of a new software library, with refactoring tool-support for their introduction in \ref{task:refactoring}; a new security-aware software engineering methodology in \ref{task:methodology}, encapsulating new software engineering methods and techniques from all the tools developed as part of the \TheProject{} project. In \ref{task:standards}, we will develop a new C++ coding standard for the development of secure big-data applications in C++. Finally, in \ref{task:interoper}, we will enable interoperability between the tools developed in the other workpackages to form a coherent software tool-chain and methodology for the end-user.


\end{WPDescription}

\begin{Task}
%\TaskTitle{Parallel Computation and Control for High-Level Modelling Languages} % for Aerospace and Automotive Industries}
\TaskTitle{Intelligent User Interface for Security-Aware Big-Data Computing}
\TaskParticipant{COGNI}{3}
\WPParticipant{YAG}{2}
\WPParticipant{USTAN}{1}
\TaskStart{1}
\TaskEnd{27}
\TaskResults{%
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:iui}
% alternative for Intelligent User Interface -> Developer-centered User Interface
In this task we will design and develop an intelligent user interface that will integrate the code refactoring component and the user authentication component as a unified interactive workbench for the developers. The refactoring component will be integrated into the ParaFormance refactoring tool, supporting both Eclipse and Visual-Studio for C++ applications. A prototype implementation for Java-based applications will also be produced. The user interface will display the outcomes from code refactoring including the secured, privacy-preserved and verified code, as well as code recommendations for improving the security and privacy aspects of the existing code. The code recommendations will be displayed following best practices and guidelines with regards to usability, user experience and user-centered design. In addition, we will implement a graphical user interface as a "wizard" that will display the recommendations (e.g., code fixes) along with the severity of each detected vulnerability and recommendation. The wizard will guide the developer through the process of refactoring the code and will provide a mechanism for easily applying the recommended changes. Furthermore, the user interface interface will provide an access point to the user authentication component for integrating two-factor authentication methods and intelligent biometrics into their code. The results of this task will be used to refactor the use-cases in \ref{wp:usecases}.

%Explainable recommendations?
%Moreover, the GUI will display the latest news on security-related threads for increasing the security-awareness of developers.


%
%In particular, in this task we will produce new refactorings that will:
%
%\begin{itemize}
%	\item Repair vulnerable code, by taking the output of the Self Healing tooling from XX, 
%	\item Introduce security-aware patterns, based on the implementation of the patterns in Task X.
%	\item Rewrite source-code so that it conforms to the standard as defined in Task X.
%\end{itemize}
\end{Task}

\begin{Task}
	%\TaskTitle{Parallel Computation and Control for High-Level Modelling Languages} % for Aerospace and Automotive Industries}
	\TaskTitle{Security-aware Software Development Patterns}
	\TaskParticipant{USTAN}{3}
	\TaskParticipant{UCM}{3}
	\TaskParticipant{UOD}{2}
	\TaskParticipant{SOPRA}{1}
	\TaskParticipant{FRQ}{1}
	\TaskStart{1}
	\TaskEnd{27}
	\TaskResults{%
		%\ref{del:model1}
	}
	\TaskHeader{}
	\tasklabel{task:patterns}
	
In \theTask{} we will formalise and implement patterns of security that arise in typical big-data applications. As part of this process, we will investigate the relationship between common security threats and their source-level solutions, producing a high-level domain-specific language (DSL) for describing a set of design patterns for the end-user. This DSL will be made available to the end-user developer as a library of security-aware patterns and will be used by the refactoring tooling from \ref{task:refactoring}. The DSL will be implemented in C++, using advanced features from the latest C++ standards, abstracting away the low-level details of programming security models.

The task will proceed in three phases. In the \emph{first} phase, we will identify a set of \emph{fundamental} patterns for repairing security vulnerabilities. These patterns will reported as high-level schemas, encapsulating the side-conditions to the pattern, the semantics of the pattern, and design models of the the pattern's implementation.
In the \emph{second} phase, we will provide implementations of the fundamental security patterns from the first phase, implemented as a C++ library. In the \emph{third} and final phase, we will extend the fundamental set of patterns, to include some advanced security patterns, and their prototype implementations in C++. If time permits, we will also provide prototype implementations of the fundamental patterns for Java-like languages. 
\end{Task}

\begin{Task}
	%\TaskTitle{Parallel Computation and Control for High-Level Modelling Languages} % for Aerospace and Automotive Industries}
	\TaskTitle{New Coding Standards for Security-Aware Applications}
	\TaskParticipant{UCM}{12}
	\TaskParticipant{SOPRA}{2}
	\TaskParticipant{USTAN}{1}
	\TaskParticipant{FRQ}{1}
		\TaskStart{1}
	\TaskEnd{27}
	\TaskResults{%
		%\ref{del:model1}
	}
	\TaskHeader{}
	\tasklabel{task:standards}
	
	In \theTask, we will develop new C++ coding and security standard to facilitate programming of secure big-data applications. The task will proceed in two phases. 
First, we will start identifying those properties related to security from multiple existing coding standards and guidelines both those that are generic and those that are language specific. We will pay special attention to issues related to programming language features. A key issue in this context is the interaction with the C
++ standard, as most guidelines and standard consider C++11 and 14 (with poor consideration to C++17 and none regarding the upcoming C++20). However, by the time this project has ended C++23 is expected to be published.

Then, we will identify for each guideline the specific enforcement means that can be used with a focus in how much of the enforcement can be automated. As a result, we will produce a new set of C++ coding guidelines that will take into consideration the multiple editions of the C++ standard.

\UCM will lead this task and will work in the development of the new set of C++ coding guidelines providing a link with the ISO C++ standards committee.

%First, we will identify those properties that arise in security-aware applications, such as secrecy of variables, branching vulnerabilities, etc.; secondly, we will implement a new security-aware programming standard, encapsulating the properties from the first phase, to create a new C++ coding standard. 
%	\begin{itemize}
%		\item Identify the language-properties relating to security 
%		\item vulnerabilities, branching, etc.? non-functional properties?
%		\item create a new C++ coding style/standard.
%	\end{itemize}
\end{Task}

\begin{Task}
	\TaskTitle{Compliance to coding standards}
	\TaskParticipant{UCM}{10}
	\TaskParticipant{USTAN}{3}
	\TaskParticipant{SOPRA}{2}
	\TaskParticipant{FRQ}{1}


	\TaskStart{1}
	\TaskEnd{27}
	\TaskResults{%
		%\ref{del:model1}
	}
	\TaskHeader{}
	\tasklabel{task:compliance}
	
	In \theTask, we will provide a common interface to multiple tools
        and components aiming to support the enforcement of the coding
        guidelines developed in Task~\ref{task:standards}.
        
     	In \theTask{} we will define refactorings that enable application to adhere to the coding standards as defined in~\ref{task:standards}. Similarly as in~\ref{task:statichealing}, we will define the refactorings as a set of formal rewrite rules, based on their pre-and post conditions and tranformation rules. The output of the refactoring will be a functionally equivalent C++ program, but with increased conformance to the C++ coding standards. We will also provide implementations of the refactorings that will feed into the end-user dashboard in~\ref{task:dashboard}. The refactorings defined in this task will work at a lower granularity than those defined in~\ref{task:statichealing}: in \theTask{}, the refactorings will rewrite specific structural features of the source-code that violate the coding standard. 
     
     This task will proceed in \emph{three} phases. In the \emph{first} phase, we will identify a set of transformation rules that will rewrite C++ programs in such a way that they conform to the C++ standards from~\ref{task:standards}. In the \emph{second} phase, we will produce implementations of the refactorings of the refactorings identified in the first phase, feeding into the end-user dashboard in~\ref{task:dashboard}.

        \UCMshort{} will contribute to this task with the implementation
        of new specific checks that can be integrated in the open source
        \texttt{clang-tidy} toolset. They will also contribute with specific
        library solutions to mitigate other vulnerabilities. 
\end{Task}

\begin{Task}
\TaskTitle{Continuous Deployment}
\TaskParticipant{UCM}{6}
\TaskParticipant{SOPRA}{4}
\TaskParticipant{IBM}{2}
\TaskParticipant{UOD}{1}
	\TaskParticipant{COGNI}{1}
		\TaskParticipant{FRQ}{1}



\TaskStart{1}
\TaskEnd{27}
\TaskResults{%
	%\ref{del:model1}
}
\TaskHeader{}

In \theTask  we will produce a new software engineering methodology for the development of secure continuous deployment methodologies.  During continuous deployment, code is typically compiled on the fly on a deployment server before being deployed to a test or run time server.  The \TheProject{} tools will become part of the Continuous Deployment workflow that will use the tools to determine a security rating for the code and if this rating is not acceptable will raise a error. This exception will stop the deployment and prevent the insecure code been deployed.
During the auto-healing phase the Continuous Deployment will ensure the latest good code is available for immediate deployment if the deployed code was compromised. The Continuous Deployment also ensures that deployments are done as a chain of smaller changes that prevents massive changes that as the risk of compromising the complete system in a single deployment. In general easier to remove small incremental changes.

In this task, we will look to assess the suitability of the tools and techniques for continuous deployment and security weakness in the tooling chain.  We will assess existing  continuous deployment  methods and their applicability to develop secure-aware applications for big data.

In the second phase of this task, we will assess the applicability of the individual tools and techniques developed on the \TheProject{} project, and their applicability to continuous deployment. 
\end{Task}

%\begin{Task}
%	\TaskTitle{Refactorings for Security Standard Conformance}
%	\TaskParticipant{USTAN}{24}
%	\TaskParticipant{SCCH}{1}
%	\TaskParticipant{IBM}{1}
%	\TaskStart{1}
%	\TaskEnd{34}
%	\TaskResults{%
%		%%\ref{del:model1}
%	}
%	\TaskHeader{}
%	\tasklabel{task:runtimehealing}
%	In \theTask{} we will define refactorings that enable application to adhere to the coding standards as defined in~\ref{task:standards}. Similarly as in~\ref{task:statichealing}, we will define the refactorings as a set of formal rewrite rules, based on their pre-and post conditions and tranformation rules. The output of the refactoring will be a functionally equivalent C++ program, but with increased conformance to the C++ coding standards. We will also provide implementations of the refactorings that will feed into the end-user dashboard in~\ref{task:dashboard}. The refactorings defined in this task will work at a lower granularity than those defined in~\ref{task:statichealing}: in \theTask{}, the refactorings will rewrite specific structural features of the source-code that violate the coding standard. 
%	
%	This task will proceed in \emph{three} phases. In the \emph{first} phase, we will identify a set of transformation rules that will rewrite C++ programs in such a way that they conform to the C++ standards from~\ref{task:standards}. In the \emph{second} phase, we will produce implementations of the refactorings of the refactorings identified in the first phase, feeding into the end-user dashboard in~\ref{task:dashboard}.
%	
%\end{Task}

\begin{Task}
	%\TaskTitle{Parallel Computation and Control for High-Level Modelling Languages} % for Aerospace and Automotive Industries}
	\TaskTitle{A Methodology for the Development of Secure Applications}
	\TaskParticipant{UCM}{1}
	
	\TaskStart{1}
	\TaskEnd{27}
	\TaskResults{%
		%\ref{del:model1}
	}
	\TaskHeader{}
	\tasklabel{task:methodology}
	
	In \theTask, we will produce a new software engineering methodology for the development of secure-aware big-data applications. In this task, we will look to assess the suitability of the tools and techniques developed within the project to support different software development models. 
	In the first phase of this task, we will assess existing  software engineering methods and their applicability to develop secure-aware applications for big data.
	In the second phase of this task, we will assess the applicability of the individual tools and techniques developed on the \TheProject{} project, and their applicability to a secure-aware software methodology. 
	Finally, in the final phase of this task, we will ensure interoperability of the tools produced in WP2, WP3, WP4, WP5 and WP6, producing an interoperable secure-aware tool-chain
	\begin{itemize}
		\item requirements capture (software engineering based?)
		\item software development models?
		\item assess applicability of tools ?
	\end{itemize}
\end{Task}


%\begin{Task}
%	\TaskTitle{How \YAG can contribute. Here are some ideas of what we could do:}
%	\TaskParticipant{YAG}{1}
%	
%	\TaskStart{1}
%	\TaskEnd{27}
%	\TaskResults{%
%		%\ref{del:model1}
%	}
%	\TaskHeader{}
%	\tasklabel{task:SastToFeedRefactoring}
%	
%	In \theTask, we can investigate how our way of doing static analysis can feed the semi automated refactoring process and tool. For instance we can search and detect specific properties of the source code, be they certain or uncertain (code smells), correlate 5them to find if a certain pattern is met and feed the refactoring.
%	We also can provide decision making information out of static analysis on "which code to refactor", on detected pre conditions as well as providing potential different options, based on semantics, to feed the refactoring.
%	\color{blue} \textbf{Limitation:} It will not be possible to modify the static analysis intermediate representation to adapt to refactoring specific needs.
%\end{Task}


%\begin{Task}
%	%\TaskTitle{Parallel Computation and Control for High-Level Modelling Languages} % for Aerospace and Automotive Industries}
%	\TaskTitle{Interoperability of the \TheProject{} Tool-Chain}
%	\TaskParticipant{UOD}{1}
%	
%	\TaskStart{1}
%	\TaskEnd{27}
%	\TaskResults{%
%		%\ref{del:model1}
%	}
%	\TaskHeader{}
%	\tasklabel{task:interoper}
%	
%	In \theTask, we will ensure the interoperability of the tools produced in WP2, WP3, WP4, WP5 and WP6. 
%	
%	\begin{itemize}
%		\item verification tools
%		\item self-healing
%		\item end-users tools
%	\end{itemize}
%\end{Task}




\begin{WPDeliverables}
\begin{compactitem}
\item \ref{del:met1} (Month 13): Report on \TheProject{} Methodology for Developing Secure Big Data Analytics on Private Clouds.
\item \ref{del:cs1} (Month 13) : Report on Initial \TheProject{} Coding Standards.
\item \ref{del:met2} (Month 25) : Report on \TheProject{} Methodology for Developing Secure Big Data Analytics on Public Clouds.
\item \ref{del:cs2} (Month 25) : Refined \TheProject{} Coding Standards.
\item \ref{del:met3} (Month 36) : Software on \TheProject{} Methodology for Developing Secure Big Data Analytics on Hybrid Clouds.
\item \ref{del:cs3} (Month 36) : Final \TheProject{} Coding Standards.
\end{compactitem}
\end{WPDeliverables}
\end{Workpackage}
