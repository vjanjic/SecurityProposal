\addtocounter{wpno}{1}
\begin{Workpackage}{\thewpno}
\wplabel{wp:patterns}
\WPTitle{\wpname{\thewpno}}
\WPStart{Month 1}
\WPParticipant{AGH}{25}
\WPParticipant{SA}{21}
\WPParticipant{INRIA}{8}
\WPParticipant{CODEPLAY}{4}
\WPParticipant{GOLEM}{3}

\begin{WPObjectives}
The objectives of \theWP{} are to:
\begin{compactitem}
\item Define and implement C/C++/SYCL \emph{components}, corresponding to building-blocks at the model level, together with the interface that allows \emph{composition} and \emph{orchestration} of these components into distributed applications;
\item Develop mechanisms for encapsulating existing code into components, thus allowing application of the \TheProject{} methodology to legacy code bases;
\item Define and implement Erlang and C++ \emph{patterns} that will abstract over common behaviour in terms of computation, communication and data distribution of the applications from the automotive, machine learning and IoT domains, together with \emph{transformations} between the equivalent pattern configurations;
\item Provide mechanisms for abstracting over properties of distributed, heterogeneous hardware systems and for developing abstract models of these systems;
\item Develop techniques for generating Erlang-based software-defined infrastructures based on properties of application components and the abstract models of hardware systems;
\end{compactitem}
\end{WPObjectives}

%% Commented out for now.  KH
%% \begin{WPDescription}
%% This workpackage deals with the C/C++ code, with the SYCL extension for programming heterogeneous 
%% computing systems, and with the methods for defining/generating software-defined infrastructures (SDIs). 
%% We consider the C/C++ code in two different ways: i) as an entry point to the \TheProject{} methodology, 
%% in the case where the existing \emph{legacy code base} needs to be adapted to use the \TheProject{}
%% modelling and implementation techniques; and, ii) as an \emph{intermediate} code generated from the 
%% high-level block-diagram model from WP2. For the former, we will provide mechanisms for encapsulating
%% parts of the legacy code into composable \emph{components} and patterns (T3.1 and T3.2), with a one-to-one
%% correspondence with the similar constructs at the block-diagram model level, thus allowing the programmer 
%% both to use the higher-level modelling techniques and to work directly at the C/C++ level. For the latter,
%% we will provide analysis methods to derive the optimal application structure (in terms of pattern composition)
%% and mechanisms to reflect this analysis to the modelling level, suggesting transformations of the 
%% application model based on the results of this analysis (T3.2). We will also provide mechanisms for 
%% specifying the details of the target hardware architectures (T3.3) and for
%% generating software-defined infrastructures based on this information (T3.4). 
%% Collectively, the techniques
%% developed in this work package, combined with the techniques from WP6, will provide statically optimised
%% C/C++ code and associated SDI that can then be compiled and deployed using techniques from WP4, and further
%% dynamically optimised using the methods from WP5. 
%% \end{WPDescription}

%% \begin{Task}
%% \TaskTitle{Pattern Implementations for Security- \& Safety-Aware Parallel Applications}
%% \TaskParticipant{SA}{4}
%% \TaskStart{3}
%% \TaskEnd{33}
%% \TaskResults{}
%% \TaskHeader{}
%% \khcomment{And another place where we introduce patterns. I think these are implementations.}
%% \khcomment{T1.3??.}
%% In \theTask{}, we will develop implementations of the patterns from T2.1 that will serve both as object code for the code generator from
%% T2.4 and for parallelisation of existing C/C++ applications. These implementations will operate at two levels:
%% i) the \emph{coordination} level, where they will link the components identified in T3.2 and allow possible nesting of patterned parallel code;
%% and 
%% ii) the \emph{component} level, where more generic fundamental patterns will be used, such as \emph{farms}, \emph{pipelines} or \emph{maps}.
%% The task will proceed in a number of phases. In the \emph{first} phase, we will implement a fundamental set of commonly-used patterns,
%% based on the requirements analysis of~\ref{del:req1}.
%% We will provide  both coordination-level and component-level implementations, and 
%% we will also identify the information that needs to be passed from the model-level patterns of WP2 to these implementation. % at the C++ level, 
%% This will enable us to ensure the consistency of the refactorings of T3.2 with the model-level refactorings of T2.3.
%% The results of this phase will be reported in Deliverable~\ref{del:cppGenericPatternsCompSafety} (M9).
%% In the \emph{second} phase, we will extend our initial implementations in line with the revised domain-specific patterns
%% that will be identified in T2.1, and 
%% will additionally incorporate the necessary security and safety checks
%% that will be provided by T6.1 and T3.5. The result of this phase will be reported in Deliverable \ref{del:cppDSPatterns} (M21). %, a report describing the 
%% In the \emph{third}, and final, phase, we will further refine our implementations
%% to incorporate improved security and safety mechanisms, and we will also take into account any requirements from the multi-objective
%% optimisation infrastructure from WP5. This will form part of Deliverable~\ref{del:finalCompSecurity} (M34). %, a software for the final C++ pattern set. ?? KH
%% \end{Task}

\begin{Task}
\TaskTitle{Components of Data-Intensive C/C++ Applications}
\TaskParticipant{SA}{7}
\TaskParticipant{INRIA}{2}
%\TaskParticipant{IBM}{4}
%\TaskParticipant{PRL}{26}
%\TaskParticipant{INRIA}{4}
%\TaskParticipant{SCCH}{6}
\TaskParticipant{CODEPLAY}{1}
\TaskParticipant{GOLEM}{0.5}
%\TaskParticipant{AGH}{4}
%\TaskParticipant{JMOIC}{4}

\TaskStart{1}
\TaskEnd{27}
\TaskResults{
\ref{del:cppComponentsPatternsInitial}
\ref{del:cppComponentsPatternsAdvanced}
\ref{del:cppComponentsPatternsFinal}
}
\TaskHeader{}
In \theTask, we will define the \TheProject{} C/C++ software \emph{components}. These components will be wrappers around 
the C/C++ computations, providing interface to them (in terms of, e.g., inputs and outputs) 
that will allow \emph{composition} of components into data-intensive applications, clearly identifying any 
computational side-effects. We will define different types of components (e.g.~computation, 
communication and operation on data), which will correspond to the equivalent components at the model 
level (WP2). We will also identify the conditions that the C/C++ code needs to satisfy, in terms of 
e.g.~inputs/outputs and libraries used, in order to be encapsulated into a \TheProject{} 
component. This will allow programmers either to port their legacy code to the \TheProject{} methodology,
or to work directly with structured C/C++ code. This task will also define a mechanism to convert existing accelerator-based code into standard SYCL C++  \TheProject{} components. This task will proceed in three phases. In the first phase,
we will define the initial versions of the definitions and interface for different kind of components. This will be reported in~\ref{del:cppComponentsPatternsInitial} (M9).
In the second phase, we will extend these components to address the specific
issues on smaller-scale distributed systems. This will be reported in~\ref{del:cppComponentsPatternsAdvanced} (M21). In the third and final phase, 
we will extend the components to large-scale distributed systems. This will be reported in~\ref{del:cppComponentsPatternsFinal} (M34).
\end{Task}

\begin{Task}
\TaskTitle{Patterns of Computation, Communication and Data Distribution}
\TaskParticipant{SA}{10}
\TaskParticipant{INRIA}{2}
\TaskParticipant{CODEPLAY}{1}
\TaskParticipant{GOLEM}{0.5}
\TaskStart{3}
\TaskEnd{33}
\TaskResults{
\ref{del:cppComponentsPatternsInitial}
\ref{del:cppComponentsPatternsAdvanced}
\ref{del:cppComponentsPatternsFinal}
}
\TaskHeader{}
In \theTask, we will develop Erlang and C/C++/SYCL \emph{patterns} to abstract over the commonly encountered
computation, communication and data distribution behaviour of data-intensive applications, with a
special focus on the patterns that arise in the specific industries that we are considering, namely
automotive, AI (machine learning) and IoT (smart cities). These patterns will have their equivalents at the
block-diagram model level. Patterns constrained to a single heterogeneous node will be based on C/C++/SYCL, whereas patterns that span multiple nodes will be based on Erlang. We will also allow composability of patterns and will extend our existing mechanisms
for static analysis of the patterned code to discover optimal patterns structure (in term of composition of 
patterns/components) with respect to e.g.~performance, reliability etc. 
%Establishing relation between the
%C/C++ and the corresponding model patterns will allow the results of the C/C++ code analysis to be reflected back
%to the model, allowing us to perform (semi-)automatic alteration of the model for the optimisation purposes.
The task will proceed in three phases. In the first phase, we will develop C/C++/SYCL patterns for heterogeneous
shared-memory systems. This will be reported in~\ref{del:cppComponentsPatternsInitial} (M9). In the second phase, we will develop Erlang patterns
for smaller-scale distributed systems. This will be reported in~\ref{del:cppComponentsPatternsAdvanced} (M21). Finally, in the third phase, we will
further extend the Erlang patterns to large-scale distributed systems. This will be reported in~\ref{del:cppComponentsPatternsFinal} (M34).
\end{Task}

\begin{Task}
\TaskTitle{Distributed Systems Modelling and Monitoring Language}
\TaskParticipant{AGH}{16}
\TaskParticipant{SA}{2}
\TaskParticipant{INRIA}{2}
\TaskParticipant{CODEPLAY}{1}
\TaskStart{1}
\TaskEnd{32}
\TaskResults{
\ref{del:SDIInitial}
\ref{del:SDIAdvanced}
\ref{del:SDIFinal}
}
\TaskHeader{}
\tasklabel{task:dsmml}
In \theTask, we will develop novel visual programming methods for defining properties of distributed systems,
similar to the block-diagram based modelling in WP2. We will also define the Distributed Systems Modelling 
and Monitoring Language (DSMML), which % will be based on some machine readable format (e.g.~json and xml) and 
will be automatically generated based on the visual description of the system. We will support four different
classes of entities that will be modelled: algorithms/computations, communication, data and hardware.
We will also develop an editor for DSMML, which will simultaneously comprise a visualisation tool. This will allow
programmers to specify the properties of the target systems for their data-intensive applications, which will then
be matched against the application structure using the runtime system mechanisms that will be developed in WP4.
This task will proceed in three phases. In the first phase, we will develop the basic version of the DSMML,
providing constructs for shared-memory heterogeneous systems. This will form part of software deliverable~\ref{del:SDIInitial} (M10). In the second
phase, we will extend the DSMML with constructs for smaller-scale distributed systems, including classes for
data transfer/distribution over these systems. This will form part of software deliverable~\ref{del:SDIAdvanced} (M22). In the third and final phase,
we will further extend the DSMML to cover large-scale distributed systems. This will form part of software deliverable~\ref{del:SDIFinal} (M35).

%% VJ : Some of this is too detailed and should go into the background section

%The task will focus on the development of the Distributed Systems Modeling and Monitoring Language (DSMML), which will allow defining distributed systems in an abstract and visual way. The language will have two major applications: design and monitoring. This novel approach will bring the process of distributed systems analysis to the new level, where the demands and plans will comply with the deployment and maintenance, allowing better understanding of static architecture and dynamic properties of the systems. 
%The language will have two equivalent representations: visual and textual. The visual representation will allow drawing a diagram of the system components and their dependencies, while the textual representation will be interpreted by the SDI Composer (T3.3). It will be stored in a human-readable form (json, yaml, xml or similar), which will allow manual modifications of the model. 
%There will be four basic classes of modeled entities: Algorithms/computations/services (A),  Communication (C), Data (D) and Hardware (H). The A-items will represent all types of computing components which should be considered parts of the system. Remote (existing) dependencies should also be included in this class. Each A-item will define its characteristics: technology, running command, hardware requirements etc. A-items will be connected using C-items, creating logical network of communication. Each C-item will also define its features and requirements, like safety, directionality or performance. D-items will be used for representing the dynamics of the system – the ability of consuming or producing data by A-items and the ability of passing the data through C-items. H-items will be fully optional and will allow different levels of detail. An  address of a particular physical computer can be replaced with partial specification of hardware.  
%Within the task, a prototype editor for the DSMML will be developed. It will allow saving, loading and editing the system configuration. After the system is deployed by the SDI Composer (T3.3), the editor will become a real-time visualization tool, which will allow monitoring and management. The visualization be enriched by elements presenting the system dynamics. 
\end{Task}


\begin{Task}
\TaskTitle{Generating Software-Defined Infrastructures}
\TaskParticipant{AGH}{9}
\TaskParticipant{SA}{2}
\TaskParticipant{INRIA}{2}
\TaskParticipant{GOLEM}{2}
\TaskParticipant{CODEPLAY}{1}
\TaskStart{3}
\TaskEnd{33}
\TaskResults{
\deliverable{ref:SDIInitial}
\deliverable{ref:SDIAdvanced}
\deliverable{ref:SDIFinal}
}
\TaskHeader{}
% \begin{itemize}
% \item DSL or something similar to describe hardware
% \item Matching the hardware description with patterns (mapping etc., possibly a part of WP4)
% \end{itemize}

In \theTask, we will implement the Erlang-based Software-Defined Infrastructure (SDI) Composer that will be responsible for
generating software-defined infrastructure (middleware) for executing the application on heterogeneous, distributed 
target systems, based on the properties of a given data-intensive application and the hardware system description in the DSMML. 
We will exploit the capabilities of Erlang for abstracting distributed computations into communicating logical processes, taking advantage of transparent mapping, scheduling and fault-tolerance mechanisms that Erlang offers. The SDI will thus be responsible for deploying the application to the hardware, for distribution of 
computations and data,  for management of the data (placement, migration, replication etc.) and 
for synchronisation of computations. It will provide an abstract communication model that will be implemented on top
of various concrete models, such as TCP, RPC or a messaging system. 
It will also serve as a basis for the monitoring mechanisms that will be developed in T4.4. 
The SDI will also expose additional parameters related to work distribution, load balancing and data 
management to the optimisation mechanisms from WP5. \theTask will proceed in three phases. In the first phase,
we will develop a basic version of the SDI composer, with the basic intra-node deployment, communication
and management model, targeting shared-memory heterogeneous systems. This will form part of software deliverable~\ref{del:SDIInitial} (M10).
In the second phase, we will extend the composer to support the generation
of infrastructure for smaller-scale distributed systems, extending the deployment, communication 
and data/computation management models to decentralised systems where communication is performed over networks. This will form part of software deliverable~\ref{del:SDIAdvanced} (M22).
In the third and final phase, we will further extend the composer to target large-scale distributed systems,
dealing with increased scale of resources by providing hierarchical communication, deployment and management
models. This will form part of software deliverable~\ref{del:SDIFinal} (M35).

%% VJ: Most of this will go to the background
%Within this task the Software Defined Infrastructure Composer will be designed and developed. The SDI Composer will be a dedicated distributed middleware, which will deploy, manage and monitor a distributed application defined in the Distributed Systems Modeling and Monitoring Language (T3.X). 
%The SDI Composer will be implemented using the Erlang technology. It will be based on the Erlang VM and will be implemented in Erlang and Elixir. This unique technology provides several key futures required by task, including autonomous processes model for massive concurrency, native distribution mechanisms with transparent inter-node communication, elegant fault handling and code updates performed on runtime. Together with several libraries and tools for distributed databases management and advanced messaging it forms a very good basis prototyping a novel approach to the distributed systems deployment. 
%The SDI Composer will be responsible for deploying the application on a suitable hardware.  The hardware will be explicitly defined in the model or defined as available for the Composer. In the second case, the Composer will inspect the available hardware and analyze the model in order to determine the possibility of running the application. It will generate possible variants of deployment, which can become the subject for optimization (TX.X). 
%The hardware available for the Composer will require only basic configuration. A lightweight process of the Composer will be run on each computing node. It will allow incorporating vast majority of existing computing hardware, from efficient cluster nodes to small embedded, ARM-based devices. The Composer will also accept nodes, which will not host the component, provided that other means of starting and monitoring of managed processes is provided. 
%The key feature of the proposed Software Defined Infrastructure Composer will be the ability of providing abstract communication layer. The processes started by the Composer may use their custom communication means (direct TCP/messaging/RPC/…). However, the Composer will provide a unified, advanced communication layer. The layer will support various models of communication, including uni- and bi-directional p2p, direct and queued messaging, multi- and brad-casting ect. All the approaches (custom and unified) will be monitored in terms of communication intensity. 
%The selected variant of the deployment strategy will be executed. This process will require proper ordering of tasks initialization -- starting components may have dependencies. Success or failure of the process will become the first step in the continuous task of distributed system monitoring (TX.X or the same T?). 
%After starting the system, the responsibilities of the Composer continue. The model defined in the Distributed Systems Modeling and Monitoring Language can contain components activated after particular evens, so the infrastructure can be adjusted on runtime. The triggering events can include communication with specific features (intensity, queue length), CPU load, available storage changes, termination of a particular process and others. Naturally, the Composer becomes a monitoring tool, which can detect various states and react automatically. 
%Another very important feature of the proposed approach is to integrate the monitoring process with the editor of the Distributed Systems Modeling and Monitoring Language. The state of the system will be visualized in real-time, using the same modeling language. The unification of the language used for design and monitoring will become novel method in distributed systems analysis. 
\end{Task}


%\begin{Task}
%\TaskTitle{Automatic Safety Checking and Repairing of the Patterned Code}
%\TaskParticipant{SA}{4}
%\TaskParticipant {PR}{8}
%\TaskStart{3}
%\TaskEnd{33}
%%\TaskResults{}
%\TaskHeader{}
%\begin{itemize}
%\item Detection of race conditions and deadlocks
%\item (Semi-)automatic repairing of these
%\item ``Puryfing'' of components, i.e.~making the components thread safe
%\item Reflecting the results of detection and repairing to the higher-level models
%\item Mapping Static Analysis compliance diagnostics to the components
%\end{itemize}
%\end{Task}


%\begin{Task}
%\TaskTitle{Distributed Systems Modeling and Monitoring Language}
%\TaskParticipant{SA}{4}
%\TaskParticipant {PR}{8}
%\TaskStart{3}
%\TaskEnd{33}
%\TaskResults{
%Deliverable 1: Preliminary design of the language – dependency for T3.3 
%Deliverable 2: Final implementation of the language and visual editor 
%}
%\TaskHeader{}

%The task will focus on the development of the Distributed Systems Modeling and Monitoring Language (DSMML), which will %allow defining distributed systems in an abstract and visual way. The language will have two major applications: design and monitoring. This novel approach will bring the process of distributed systems analysis to the new level, where the demands and plans will comply with the deployment and maintenance, allowing better understanding of static architecture and dynamic properties of the systems. 
%The language will have two equivalent representations: visual and textual. The visual representation will allow drawing a diagram of the system components and their dependencies, while the textual representation will be interpreted by the SDI Composer (T3.3). It will be stored in a human-readable form (json, yaml, xml or similar), which will allow manual modifications of the model. 
%There will be four basic classes of modeled entities: Algorithms/computations/services (A),  Communication (C), Data (D) and Hardware (H). The A-items will represent all types of computing components which should be considered parts of the system. Remote (existing) dependencies should also be included in this class. Each A-item will define its characteristics: technology, running command, hardware requirements etc. A-items will be connected using C-items, creating logical network of communication. Each C-item will also define its features and requirements, like safety, directionality or performance. D-items will be used for representing the dynamics of the system – the ability of consuming or producing data by A-items and the ability of passing the data through C-items. H-items will be fully optional and will allow different levels of detail. An  address of a particular physical computer can be replaced with partial specification of hardware.  
%Within the task, a prototype editor for the DSMML will be developed. It will allow saving, loading and editing the system configuration. After the system is deployed by the SDI Composer (T3.3), the editor will become a real-time visualization tool, which will allow monitoring and management. The visualization be enriched by elements presenting the system dynamics. 
%\end{Task}



%\begin{Task}
%\TaskTitle{Pattern Transformations for Security, Performance, Reliability and Robustness}
%\TaskParticipant{SA}{4}
%\TaskStart{3}
%\TaskEnd{33}
%\TaskResults{}
%\TaskHeader{}
%\end{Task}



%% \begin{Task}
%% \TaskTitle{Parallel Component Identification}
%% \TaskParticipant{SA}{2}
%% \TaskStart{1}
%% \TaskEnd{28}
%% \TaskResults{}
%% \TaskHeader{}
%% In \theTask, we will define the conditions that a source-code fragment must satisfy in order to be considered a \emph{component},
%% that is to be a  building block in a patterned parallel application. We will also define
%% the interfaces that will be used to connect the components into parallel application by coordination patterns 
%% developed in T2.2 and T3.1. The component description will be used as input to the Modelling Language and modelling patterns
%% in T2.1 and T2.2, and also as input to the patterns in T3.1 and the refactorings in T3.3 and T2.4. The description 
%% of the component will contain both the functional and the extra-functional properties that are required in order to satisfy 
%% the requirements of the use-cases. These properties will include a precise description of the inputs and outputs to the components, such as any restrictions 
%% on C/C++ references, pointers, accesses to shared variables, etc. The extra-functional properties of the component will include safety 
%% and security descriptions that satisfy the requirements of T2.5 and T6.1. Components will also contain an implementation 
%% in the form of e.g. a C++ class or template or a C interface, that is directly programmable and that is amenable to source-to-source refactoring using
%% the transformations of T3.3. and that can be targeted by the modelling languages of WP2.
%% %Furthermore, components
%% They will be engineered in such as way as to allow different degrees of security,
%% as defined by T6.3. \theTask{} will proceed in two phases. In the first phase, we will provide an initial description of components
%% for generic parallel patterns (Deliverable~\ref{del:cppGenericPatternsCompSafety}, M9). In the second phase, we will extend this with
%% the additional requirements for domain-specific patterns, and also any additional security, safety and optimisation issues
%% identified by T6.1, T6.3, T2.5 and T5.3 (Deliverable~\ref{del:cppFinalPatterns}, M28).
%% \end{Task}

%% \begin{Task}
%% \TaskTitle{Refactoring for Pattern Introduction and Tuning}
%% \TaskParticipant{SA}{8}
%% \TaskStart{3}
%% \TaskEnd{32}
%% \TaskResults{}
%% \TaskHeader{}
%% In \theTask, we will develop semi-automatic source-to-source refactorings that support the introduction and tuning
%% of parallel patterns, both at the coordination level and at the component level, providing implementations in
%% widely-used IDEs, such as Visual Studio or Eclipse.
%% Specifically, we will develop new source-level refactorings that will: i) introduce parallel patterns into
%% the original C/C++ code; ii) transform between alternative equivalent pattern structures; and,
%% iii) prepare code for the introduction and/or reshaping of parallelism. We will develop formal rules for each
%% code transformation, formalising both the code transformation itself and all the pre- and post-conditions
%% that must hold before and after the transformation. 
%% We will build on existing prototype tooling and refactorings in Eclipse and Visual Studio that have been developed as
%% part of the \rephrase{} and \paraformance{} projects.
%% This task will receive input from the static and dynamic
%% analyses for pattern discovery and safety checking (T3.4 and T3.5). % and will feed into T2.6 (integration).
%% In particular, the pre-conditions of the refactorings will take into account the security principles defined in
%% WP6, in order to support security-aware pattern-based programming and components. 
%% %
%% The task will proceed in three phases. In the \emph{first} phase, we will develop new refactorings
%% to introduce the coordination-level and component-level generic patterns from the
%% first phase of T3.1. This will be reported in Deliverable~\ref{del:cppGenericPatternsCompSafety} (M9). In the \emph{second} phase, we will
%% develop the additional refactorings that are needed for the domain-specific patterns from second phase of T3.1, and will also take into account
%% the security considerations from T6.1. This will be reported in Deliverable~\ref{del:cppDSPatterns} (M21). In the \emph{final} phase, we will
%% modify the refactorings to take into account additional requirements from the third phase of T3.1, 
%% as well as the updated security requirements from T6.1. This will form part of Deliverable~\ref{del:finalCompSecurity} (M34).
%% \end{Task}

%% \begin{Task}
%% \TaskTitle{Automating Parallel Pattern Discovery}
%% \TaskParticipant{SA}{4}
%% \TaskStart{3}
%% \TaskEnd{31}
%% \TaskResults{}
%% \TaskHeader{}
%% In \theTask, we will develop code analyses to discover source-code fragments that are
%% amenable for parallelisation. This includes both i) fragments that can be immediately
%% parallelised (because they are completely independent); as well as ii) fragments that may need to undergo some transformations
%% prior to the introduction of parallelism (e.g. because they access shared variables).
%% %  to
%% % eliminate the conditions that prevent parallelisation, such as shared access to global
%% % variables; 
%% Fragments that may obstruct parallelisation can be \taskbreak identified by the inputs of the static
%% %
%% safety checking analyses, as defined in T3.5. 
%% We will develop static analyses for identifying potentially parallel % but unprovable regions of
%% code fragments. % , including both source code and compile-time analyses. 
%% We will also develop new dynamic analyses based on profiling. In this way
%% we will be able to leverage the varying strengths of both static and dynamic approaches and discover a wide range of
%% parallel patterns in the application code, both directly from the program source and from the executable code.
%% By integrating these analyses with the refactoring mechanisms from T3.3, we will enable them to be used
%% from within widely-used IDEs, including Visual Studio and Eclipse.
%% \theTask{} will proceed in three phases. In the \emph{first} phase, we will develop static
%% analyses to find possible instances of generic patterns in suitable C/C++ source code. The results
%% of this phase will be reported in Deliverable~\ref{del:cppGenericPatternsCompSafety} (M9). In the \emph{second} phase,
%% we will extend the pattern discovery technique to also operate at compile-time,
%% taking input from WP5, and wuill also extend it to include automated discovery of domain-specific patterns. 
%% This will be reported in Deliverable~\ref{del:cppDSPatterns} (M21).
%% Finally, in the \emph{third} phase we will develop new profiling-based pattern discovery mechanisms.
%% This will be delivered as part of Deliverable~\ref{del:finalCompSecurity} (M34).
%% %\begin{itemize}
%% %\item Maybe separate out into discovering components (or instances of) and coordination?
%% %\end{itemize}
%% \end{Task}

%% \begin{Task}
%% \TaskTitle{Safety/Security Checking and Repair of Parallel Code}
%% \TaskParticipant{SA}{5}
%% \TaskStart{1}
%% \TaskEnd{32}
%% \TaskResults{}
%% \TaskHeader{}
%% \khcomment{You need to be 100\% clear whether these are new, or if not how they extend existing approaches.}
%% \khcomment{Changed to three phases in line with GANTT chart.}
%% \khcomment{Mentioned IDEs.}
%% \khcomment{Both static and dynamic? There's not much time in this task.}
%% In \theTask, we will develop new static and dynamic analysis mechanisms for detecting
%% conditions that could possibly prevent the correct parallelisation of the C/C++ source code,
%% or that could lead to security vulnerabilities, as identified by WP6. 
%% We will also develop new mechanisms to allow semi-automatic \emph{code repair} for these conditions, 
%% suggesting possible code corrections to the programmer and providing corresponding refactorings.
%% This will dramatically simplify the parallelisation process for non-expert developers.
%% We will integrate these mechanisms with the refactorings of T3.3/T3.4, enabling them to be used from widely-used IDEs, such as Visual Studio and Eclipse.
%% Relevant safety/security concerns include, for example,
%% simultaneously accessing a shared variable within a loop.  This could lead to
%% \emph{race conditions} that could have unpredictable results or lead to security violations. 
%% \khcomment{Relationship between threads and components must be made clear.}
%% This work will include detecting and repairing race conditions on induction variables
%% (variables that are declared outside the scope of a parallel thread, but that are updated by different
%% threads), on stack traces, and on array indexes. 
%% % through polyhedral analyses of 
%% \khcomment{polyhedral analysis is a detection technique, isn't it?}
%% We will build on existing state-of-the-art work that has been previously developed in the \rephrase{} and \paraformance{} projects and elsewhere
%% (Section~\ref{sect:codeAnalysis}). We will extend this previous work to cover the new patterns and implementations that we will develop in \TheProject{}, and to address the
%% security concerns from WP6.
%% % We will also develop new mechanisms to allow semi-automatic \emph{code repair} for the conditions that we have
%% % identified, suggesting possible code corrections to the programmer and providing corresponding refactorings, building
%% % on the work of T3.3. 
%% % , using techniques that build on the semi-automated
%% % refactoring approach in T3.3. 
%% % \theTask{} will also take into account the security considerations from WP6. 
%% % \khcomment{Should explain how!}  Moved above.
%% This task will proceed in three phases.
%% In the \emph{first} phase, we will develop a set of basic safety checks on components such as
%% induction variable analysis, polyhedral array indexing, etc. This will be reported in
%% Deliverable~\ref{del:cppGenericPatternsCompSafety} (M9). In the \emph{second} phase, we
%% will enhance these checks to include security concerns, and investigate techniques to \emph{repair} code so that it no longer violates the safety checks from the first phase,
%% and these additional security checks.
%% This will be reported in Deliverable~\ref{del:cppDSPatterns} (M21).
%% In the \emph{final} phase, we will develop new refactorings that that can be used to repair
%% code, under programmer guidance. These refactorings
%% will be integrated into the Refactoring tool from T3.3, and will form part of Deliverable~\ref{del:finalCompSecurity} (M34).
%% %\begin{itemize}
%% %\item induction variables?
%% %\item repair of safety violations? Link to Turkey's work?
%% %\item safety checking also include security infringements?
%% %\item not to be confused with model level safety and/or security
%% %\end{itemize}


%% \end{Task}

%\begin{Task}
%\TaskTitle{Integration into Front-End Tools}
%\TaskParticipant{SA}{2}
%\TaskStart{?}
%\TaskEnd{?}
%\TaskResults{%
%\ref{del:frontool}
%}
%\TaskHeader{}
%In this task, we will explore integration of the Refactorings developed T3.3, the Safety Checking from T3.5 and the Pattern Discovery from T3.4  into state-of-the-art Integrated Development Environments (IDEs), such as Visual Studio and Eclipse. This task will include a design of the user interface, including menus and displaying the results of the refactored code and analyses. The result of this task will be a report describing the user interfaces and IDE integration in Deliverable D3.X (MXX).
%\begin{itemize}
%\item Is this needed as a separate task?
%\item Mention about generally visualising refactorings/errors/discovery results?
%\end{itemize}
%\end{Task}

\begin{WPDeliverables}
\begin{compactitem}
\item \ref{del:cppComponentsPatternsInitial} (Month 9): Report on Initial Components and Patterns
\item \ref{del:SDIInitial} (Month 10): Software on Initial Design and Generation of Software-Defined Infrastructures
\item \ref{del:cppComponentsPatternsAdvanced} (Month 21): Report on Refined Components and Patterns
\item \ref{del:SDIAdvanced} (Month 22): Software on Refined Design and Generation of Software-Defined Infrastructures
\item \ref{del:cppComponentsPatternsFinal} (Month 33): Report on Final Components and Patterns
\item \ref{del:SDIFinal} (Month 34): Software on Final Design and Generation of Software-Defined Infrastructures
\end{compactitem}
\end{WPDeliverables}
\end{Workpackage}
