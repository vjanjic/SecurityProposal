fro\addtocounter{wpno}{1}
\begin{Workpackage}{\thewpno}
\wplabel{wp:compilation}
\WPTitle{\wpname{\thewpno}}
\WPStart{Month 1}
\WPParticipant{CODEPLAY}{24}
\WPParticipant{INRIA}{8}
\WPParticipant{AGH}{8}
\WPParticipant{SA}{6}
\WPParticipant{GOLEM}{2}


\begin{WPObjectives}
The objectives of \theWP{} are to:
  %\textbf{DRAFT}
  \begin{compactitem}
  \item Extend the SYCL runtime with new functionality to execute kernels on distributed nodes in the cloud;
%  \item Targeting modern GPU platforms with SYCL 
%  \item Extend the SYCL runtime system with just-in-time compilation and optimisation mechanisms;\comment{}

  \item Develop infrastructure for static mapping and dynamic remapping of application tasks and data to parallel and distributed hardware
  to support multi-objective optimisation;

  \item Develop a monitoring framework for large-scale distributed data-intensive applications to gather the metrics that are required for the multiobjective optimisations of WP5.
  \end{compactitem}
  
\end{WPObjectives}

%% \begin{WPDescription}
%% This workpackage deals with the issues of compilation and execution of parallel code for massively-parallel hardware.
%% The infrastructure in this workpackage receives an input C/C++ code with parallel patterns, and prepares it
%% for the execution on the target hardware, including adding adaptivity capabilities that are required for dynamic
%% optimisations performed in WP5. 
%% % We will build on the existing PAXXX compiler developed by the \UMshort{} and
%% % extend it with multi-stage compilation support that will allow dynamic recompilation of the code (\textbf{T4.1}).
%% % We will also develop runtime support for just-in-time compilation based on multi-staging compiler and build
%% % adaptation framework that will be able to modify applications while they execute, by replacing components with
%% % their alternative versions as response to decisions made by the multiobjective optimisation framework (\textbf{T4.2}).
%% % An important part of the whole process is mapping of the tasks and threads of the parallel application (\textbf{T4.3})
%% % to the target hardware, both to achieve time predictability of the execution (using static mapping) or to dynamically
%% % improve performance, energy efficiency etc. while the application is running (using dynamic mapping). Finally, we
%% % will develop framework for monitoring the execution of parallel applications and collecting runtime metrics that
%% % will be fed to the multiobjective optimisation tools to decide when runtime optimisationis required (\textbf{T4.4}).
%% \end{WPDescription}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Task}
\TaskTitle{Analysis of SYCL C++ components}
\TaskParticipant{CODEPLAY}{9}

\TaskStart{1}
\TaskEnd{29}
\TaskResults{
\ref{del:runtime1}
\ref{del:runtime2}
\ref{del:runtime3}
\ref{del:runtime4}
}
\TaskHeader{}
\tasklabel{task:syclcomponents}
In \theTask, we will define requirements, constraints  and objectives for static mapping, producing suitable annotations that can be used on the components. We will also investigate just-in-time (JIT) compilation of SYCL kernels and develop optimisations to compile kernels from a set of kernels (in a library) lazily to reduce compile times and to better hide the latency of the compilation. These mechanisms will be integrated into static mapping framework from~\ref{task:mapping}. For this purpose, we will utilise GNU attribute system to control offline compilation of SYCL code which will then be passed to the runtime, triggering the JIT processing of the requested kernel. This task will proceed in three phases. In the first phase, we will define and implement the required annotations providing the prototype for integrating the static mapping with the annotated components. This will be a part of software deliverable~\ref{del:runtime1}.
In the second phase, we will add JIT support on the intermediate representation (IR) level. This will be a part of software deliverable~\ref{del:runtime2}.
In the third phase based on the information (patterns and annotations) generated by WP3 we apply kernel-level optimisations (triggered by the runtime). This phase will also optimise the JIT processing. This will be a part of software deliverable~\ref{del:runtime3} and will be reported in~\ref{del:runtime4}.

\comment{CODE} {
We will extend the traditional
``from source to binary'' approach in order to enable manipulating the
program code after the compilation, designing a novel multi-stage compilation approach
based on intermediate representation (IR) of the code,
where the first stage is the offline compilation and the remaining stages are performed
online at runtime.
%
This task will proceed in three phases. In the \emph{first} phase, we will develop
the basic multi-stage compiler. This will be reported in  Deliverable~\ref{del:basicCompilation} (M10). In the
\emph{second} phase, we will extend the compiler according to requirements
from the multi-objective optimisation techniques from WP5, to tune and optimise the
instruction representation (IR) to allow for extra-functional properties of the applications. We will also extend the compiler
to gather the additional metrics that are required by the multi-objective optimisation tools and
to provide information to the safety checking and pattern discovery mechanisms
of T3.4 and T3.5. This will be reported in  Deliverable~\ref{del:refinedCompilation} (M22). In the \emph{third}, and final, phase,
we will further adapt the compiler to provide improved support for dynamic recompilation
of the code and to further integrate with the multi-objective optimisation approach. This
will be reported in Deliverable~\ref{del:finalCompilation} (M34).
}
\end{Task}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Task}
\TaskTitle{Runtime Systems}
\TaskParticipant{CODEPLAY}{13}
\TaskParticipant{USTAN}{3}
\TaskParticipant{INRIA}{3}
\TaskParticipant{GOLEM}{1}
\TaskStart{4}
\TaskEnd{34}
\TaskResults{
\ref{del:runtime1}
\ref{del:runtime2}
\ref{del:runtime3}
\ref{del:runtime4}
}
\TaskHeader{}

In this task we extend the runtime of our existing SYCL implementation (ComputeCPP) with the capability to launch SYCL kernels on distributed nodes in the cloud. This allows large C/C++/SYCL programs with hundreds or thousands of kernels (such as the machine learning integration of SYCL with TensorFlow) to schedule different parts of the program and its flow graphs for execution on different heterogeneous nodes in the cloud-like systems. While the SYCL compiler/runtime interface will stay largely the same to enable existing SYCL programs to be run without recompilation (some extensions to the compiler may be required), the SYCL runtime will be extended to perform various tasks currently executed on the host on distributed nodes. This means the current interaction of the SYCL runtime with the underlying accelerator API (OpenCL) will happen over the network by utilising existing network libraries. Nodes in the network need to identify themselves to the runtime with their capabilities and performance characteristics to help the SYCL runtime with scheduling the execution of kernels. The compiler may be extended to express certain details about for example scheduling hints about how and where in the cloud SYCL kernels should be executed. These details may be hidden inside a standard C++ API. This task will proceed in three phases. In the first phase, we extend the SYCL runtime with mechanisms to launch kernels on different heterogeneous nodes in the cloud, but also on different devices on the same node. This will form part of software deliverable~\ref{del:runtime1} (M10).
In the second phase, we define actuators to communicate static mapping (~\ref{task:mapping}) and dynamic remapping (WP5) of SYCL C++ components in the cloud. This will be a part of software deliverable~\ref{del:runtime2} (M22).
The third phase will integrate the SYCL kernel launcher with the Erlang Monitoring tools to benefit from performance monitoring (\ref{task:monitoring}) and extract performance metrics used for multiobjective optimisation (WP5). This will be a part of software deliverable~\ref{del:runtime3} and also reported in~\ref{del:runtime4} (both M34).

\end{Task}

%%\comment{CODE}{
%%begin{Task}
%%\TaskTitle{Runtime Systems}
%%\TaskParticipant{SA}{1}
%%\TaskStart{2}
%%\TaskEnd{34}
%%\TaskResults{
%%\ref{del:runtime1}
%%\ref{del:runtime2}
%%\ref{del:runtime3}
%%\ref[del:runtime4}
%%}%
%%\TaskHeader{}

%%This task will develop the runtime system for applications that are compiled with the multi-stage compiler
%%of T4.1. The runtime system will be responsible for finalizing the IR generated %
%%by the compiler to an executable representation, as well as dynamically modifying the application
%%to implement the decisions made by the multi-objective optimisation framework from WP5. 
%%By using 
%%multiple compilation stages,
%%we will enable the incorporation of values that are only known 
%%during execution of the program (e.g., the size  of the input of our patterns) into the IR 
%%that is generated by the compiler. This will allow optimisation of the binary code and the creation of
%%specialised versions of the parallel patterns, tailored to the use cases. The task \taskbreak
%%will proceed 
%%in three phases. In the \emph{first} phase, we will develop the infrastructure
%%necessary for just-in-time (JIT) compilation of the injected IR. We will also develop a basic
%%version of the modular software stack for executing parallel code on different target architectures. This will be reported
%%in  Deliverable~\ref{del:basicCompilation} (M10). In the \emph{second} phase, we will extend the runtime system to allow for 
%%optimisations of the parallel code through exploitation of the multi-staging compilations 
%%approach. We will also add an interface to the multi-objective optimisations of  WP5. This
%%will be reported in  Deliverable~\ref{del:refinedCompilation} (M22). In the \emph{third} phase, we will further extend %%the 
%%runtime system to allow for re-optimization and re-compilation of the parallel code, as well 
%%as for rescheduling or migration from one target device to another. 
%%This
%%will be reported in  Deliverable~\ref{del:finalCompilation} (M34).
%%\end{Task}
%%} %%COMMENT

\begin{Task}
\TaskTitle{Mapping Components to the Parallel Hardware}
\TaskParticipant{INRIA}{4}
\TaskParticipant{USTAN}{3}
\TaskParticipant{CODEPLAY}{2}
\TaskParticipant{GOLEM}{0.5}
\TaskStart{3}
\TaskEnd{32}
\TaskResults{
\ref{del:runtime1}
\ref{del:runtime2}
\ref{del:runtime3}
\ref{del:runtime4}
}%
\TaskHeader{}
\tasklabel{task:mapping}
This task will develop infrastructure for mapping application components onto the 
target hardware. \TheProject{} applications derived from the models of \ref{wp:models}
will comprise a potentially huge number of lightweight interlinked components with the associated data.
We will develop mechanisms to group these components into more coarse-grained \emph{tasks} where the architecture is less parallel,
and to then map these, together with the associated data, to processor cores (or to groups of cores), and memory banks, as appropriate for the target architecture. 
We will consider both \emph{static} (compile-time) mapping, where placement of tasks and data does not change during the application
execution and which benefits from making applications more time predictable, and 
\emph{dynamic} (runtime) mapping, where tasks and data can be remapped  to different resources during
execution, to optimise for different runtime metrics. The task will
proceed in three phases. In the \emph{first} phase, we will develop basic static mapping mechanisms
that will aim to optimise performance of the applications and that will be incorporated through~\ref{task:syclcomponents} into the SYCL compiler. This will form  part of software deliverable~\ref{del:runtime1} (M10). In the second phase, we will
extend this to i) include dynamic remapping of the tasks in response to requests from
the multi-objective optimisation infrastructure; ii) include domain-specific needs from the applications from automotive, AI and IoT; and, iii) include mapping to the distributed architectures. This will form part of~\ref{del:runtime2} (M22). Finally,
in the \emph{third} phase, mapping techniques will be further refined to respond to dynamic
recompilation and restructuring of the parallel code, and will also be adapted to the
updated version of multi-objective optimisation infrastructure in the third phase of 
WP5 and to large-scale distributed architectures. 
This will form part of software deliverable~\ref{del:runtime3} and will also be reported in~\ref{del:runtime4} (both M34).
\end{Task}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Task}
\TaskTitle{Monitoring of Patterned Applications}
\TaskParticipant{AGH}{8}
\TaskParticipant{INRIA}{1}
\TaskParticipant{GOLEM}{0.5}
\TaskStart{3}
\TaskEnd{29}
\TaskResults{
\ref{del:runtime1}
\ref{del:runtime2}
\ref{del:runtime3}
\ref{del:runtime4}
}%
\TaskHeader{}
\label{task:monitoring}
In this task, we will develop an infrastructure for monitoring the execution of  data-intensive applications developed using the \TheProject{} methodology when executed on parallel or distributed  hardware systems. This infrastructure will serve two purposes. Firstly, it will collect various low-level runtime metrics from the application execution (such as number of instructions executed, data accesses, cache misses and data transfers), aggregate them and send them to the multiobjective optimisation framework, which will them make various application tuning decisions based on them. Secondly, it will give high-level information to the programmer about the progress of the application, allowing them to identify potential problems and make changes to the application model. The latter will use the DSMML notation defined in~\ref{task:dsmml}. The task will proceed in three phases. In the first phase, we will develop initial monitoring infrastructure targeting shared-memory systems. This will form part of software deliverable~\ref{del:runtime1} (M10). In the second phase, we will extend this infrastructure to monitor distributed applications on small-scale distributed systems. This will form part of software deliverable~\ref{del:runtime2} (M22). In the third phase, we will further extend this infrastructure to large-scale distributed systems. This will form part of software deliverable~\ref{del:runtime3} and will also be reported in~\ref{del:runtime4} (both M34).
\end{Task}



\vspace{-10pt}
\begin{WPDeliverables}
\begin{compactitem}
\item \ref{del:runtime1} (Month 10): Software for Initial \TheProject{} Compilation, Mapping, Runtime Support and Monitoring Infrastructure for Shared-Memory Heterogeneous Systems;
\item \ref{del:runtime2} (Month 22): Software for Intermediate \TheProject{} Compilation, Mapping, Runtime Support and Monitoring Infrastructure for Small-Scale Distributed Heterogeneous Systems;
\item \ref{del:runtime3} (Month 34): Software for Final \TheProject{} Compilation, Mapping, Runtime Support and Monitoring Infrastructure for Large-Scale Distributed Heterogeneous Systems;
\item \ref{del:runtime4} (Month 34): Report on the \TheProject{} Runtime Infrastructure
\end{compactitem}


%%\begin{compactitem}
%%\item D4.1 (Month 8) Report: Analysis of runtime infrastructure requirements and initial integration of static mapping
%%\item D4.2 (Month 10)
%%Software for adapting SYCL runtime to support distributed systems (launch kernels on distributed nodes)
%%\item D4.3 (Month 22) Report: Refining runtime infrastructure to support modern platforms with accelerators integrating static mapping  
%%\item D4.4 (Month 23) Software to add runtime support to enable distributing tasks across different types of devices, integrating static mapping 
%%\item D4.5 (Month 33) Report for finalising and optimising runtime infrastructure  
%%\item D4.6 (Month 34) Software support to implement and finalise runtime optimisations      
%%\end{compactitem}

\end{WPDeliverables}

\end{Workpackage}
