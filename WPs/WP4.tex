\addtocounter{wpno}{1}
\begin{Workpackage}{\thewpno}
\wplabel{wp:securityContracts}
\WPTitle{\wpname{\thewpno}}
\WPStart{Month 1}
\WPParticipant{USTAN}{17}
\WPParticipant{UCM}{14}
\WPParticipant{SCCH}{13}
\WPParticipant{YAG}{6}
\WPParticipant{IBM}{5}
\WPParticipant{SOPRA}{2.5}


\begin{WPObjectives}
The objectives of \theWP{} are to:
\begin{compactitem}
%\item Develop a formal high-level multi-level specification language; 
\item Develop a formal high-level multi-level language for specification of security properties of the code. 

\item Define abstraction/refinement as a bidirectional transformation between specifications across levels.

% How is distribution considered?
%BOTH for source code and code patterns that represent known vulnerabilities 
%and relate different levels of abstraction (from models to code)

%\item Define a notion of behavioural equivalence between code fragments (within/between language(s)), able to capture refactorings, and suitable to formalise security and privacy-preserving equivalences;
%\item Define a notion of behavioural equivalence (in terms of security and privacy-preserving properties) between code fragments;
\item Define a behavioural equivalence (in terms of security and privacy properties) between code fragments.

%\item Define a logic to capture properties of interest including security properties and privacy norms;
% VJ: How is above different from the first point and can they be merged?

%\item Develop an integrated verification framework, including theorem provers and SMT solvers, to prove the correctness of the equivalences and transformation and 
%%, and capable of searching for (a subset of) traces of execution that satisfy certain parameters (meet a certain threshold for instance);
% explore an interplay between runtime verification and exhaustive formal verification;
\item Develop an integrated verification framework to prove the correctness of the equivalences and transformation and 
%%, and capable of searching for (a subset of) traces of execution that satisfy certain parameters (meet a certain threshold for instance);
explore an interplay between runtime verification and exhaustive formal verification.

 \item  Verify the correctness of the mechanisms from WP2 for vulnerability detection and self-healing.
%\item Develop a novel mechanism for automated vulnerability localisation, containment, recovery and repair.

\end{compactitem}

%Needs to be related to WP2 and vulnerabilities 
\end{WPObjectives}

%% Old WP Description
%\begin{WPDescription}
%\theWP{} explores how rigorous formal methods can %continuously 
%provide systematic guarantees of security and privacy in 
%software systems at different levels of abstraction.
%%our software systems.
%%Establishing whole-system security for end-user software is crucial but particularly challenging for distributed systems.
%%The scale of distributed systems requires the development of methods for security assurance that are modular, compositional and 
%%incremental. As these systems evolve over time, and are often built using existing service components exporting an API that can be used by components developed later,  
%%security cannot be verified once but has to be done incrementally as the systems evolve.
%%We need  to specify and ensure the security of the whole system and not just individual components or abstraction layers within a system. 
%We define the abstractions to present to the programmer, provided by the operating system, architecture, and so on (Task~\ref{task:contracts}), and introduce a specification language to capture the assumptions and guarantees of abstraction layers to facilitate reasoning about security across abstraction levels.
%% (Task~\ref{task:formalverif}). 
%The abstractions should expose security properties in a form understandable to (non-security specialist) programmers. We adopt Abstract State Machines (ASMs), given our experience in extracting ASMs from source code automatically. 
%The ability to move between layers with this approach and target the extraction of vulnerabilities from code for verification at higher levels will be key.
%Similarly, we will define this as a model for our functionally equivalent code, aka refactorings, and automatically search for alternative refactorings such that their security guarantees are preserved, or conversely, detected vulnerabilities are avoided (Task~\ref{task:formalverif}).
%Concerning privacy, complementary to the work on privacy-preserving machine learning algorithms of WP3, we will consider privacy expectations expressed using context-relative informational norms, formalised in logic (e,g. FOL) and automatically checked across traces of execution (Task~\ref{task:formalverif}).  
%By explicitly modelling the computer system and the abilities of adversaries, formal methods can prove that the computer system is secure against all possible attacks (up to modelling assumptions). This provides high assurance of system security, even against as-yet-unknown attacks (Task~\ref{task:attackmodels}).
%%as formal approaches in practice with the use of tools such as the ones from IBM, static analyser from YAG and code extractor from SCCH. 
%\theWP{} explores the integration of formal methods with the practical techniques from WP2, supports the tools from WP6 and is evaluated throughout with the use cases described in WP7.
%We will further investigate the gaps or intersections between some of these approaches, enable their interoperability and hence avoid missing potential vulnerabilities at different layers of abstraction (%Task~\ref{task:dyncontracts} and 
%Task~\ref{task:ContractsSastAssessment}). 
%For functional security requirements we will explore the use of metrics such as confidentiality, integrity and availability to assess them (Task~\ref{task:RequirementsSastAssessment}).
%\end{WPDescription}

%% New WP Description
\begin{WPDescription}
\theWP{} aims to use formal methods to systematically guarantee security and privacy of big data analytics.
We will define the abstractions for describing security properties of the code in a form understandable to software developers and introduce a specification language to capture the security and privacy assumptions and guarantees (\ref{task:contracts}). We will adopt Abstract State Machines (ASMs) as an approach to move between the layers of abstraction and to extract vulnerabilities from the code for verification. ASMs will be used as a model for refactorings from WP2 and WP6, allowing us to automatically search for alternative refactorings that preserve security guarantees and avoid vulnerabilities (\ref{task:formalverif}). \ref{task:formalverif} will also consider privacy expectations expressed using context-relative informational norms, formalised in logic (e.g. FOL) and automatically checked across traces of execution. By explicitly modelling the computer system and the abilities of adversaries, formal methods can prove (up to modelling assumptions) that the system is secure against all possible known and yet-unknown attacks (\ref{task:attackmodels}). Furthermore, we will investigate the gaps or intersections between some of these approaches, enable their interoperability and hence avoid missing potential vulnerabilities at different layers of abstraction (\ref{task:ContractsSastAssessment}). For functional security requirements, we will explore the use of metrics such as confidentiality, integrity and availability to assess them (\ref{task:RequirementsSastAssessment}).
\end{WPDescription}

\begin{Task}
\TaskTitle{Security Contracts support and specification}
\TaskParticipant{UCM}{8}
\TaskParticipant{USTAN}{4}
\TaskParticipant{SCCH}{4} 
\TaskParticipant{IBM}{1}
\TaskParticipant{SOPRA}{1}
\TaskStart{1}
\TaskEnd{34}
\TaskResults{%
\ref{del:formal1},
\ref{del:formal2},
\ref{del:formal3}
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:contracts}

%% VJ: Old version
%\theTask will define mechanisms to represent security contracts which will describe security properties of the code. The contracts will be mapped to concrete syntax in different
%programming languages. Conversely, we will enable the extraction of those contracts
%from existing source code and  allow developers to refine them iteratively. The contract extraction will be formalised with ASMs.
%This task will proceed in three phases.
%The first phase will focus on the representation of security contracts and add to the \textsf{eKnows} module for semi-automated extraction of ASMs from source code (which currently works for Java code) the capability to extract ASMs from C++ code. Since the module is based on abstract syntax trees and designed for multi-language reverse engineering, this first step is relatively straightforward.
%We will provide initial formalisation of the security contracts in (temporal) logics for ASMs and interpreted over the code extracted ASMs (\ref{del:formal1}).
%The second phase will focus on more sophisticated higher-level abstractions
%for the different programming languages considered and identified programming patterns. The formalisation and logics used will be adapted to the new abstractions as required (\ref{del:formal2}).
%The third phase will refine the previous approach to
%take into account the semantics of the libraries used in the targeted distributed data analytics systems.
%We envisage a set of hierarchical logics such that reasoning across levels of abstraction is supported.
%This will give us a unifying formalism for the rigorous verification of the envisaged security contracts across multiple layers. This will be reported in \ref{del:formal3}.
%\UCM leads this task with their expertise in specifying contracts at different levels and programming languages. \SA and \SCCHshort will work closely on the formalisation and extension of \textsf{eKnows} combining their expertise in semantics, distributed logics and ASMs. \IBMshort and \SOPRAshort will provide expertise on the identification of security vulnerabilities.

% VJ: New Version
\theTask{} will define \emph{security contracts} describing security properties of the code. These are mapped to concrete syntax in different
programming languages and, conversely, extracted using ASMs from source code. The task will proceed in three phases.
The \emph{first} phase focuses on the representation of security contracts;  extending \textsf{eKnows} for semi-automated extraction of ASMs from source code with C++ support; and providing an initial formalisation of the security contracts in (temporal) logics for ASMs (\ref{del:formal1}). The \emph{second} phase develops more sophisticated abstractions for identified programming patterns in C++/Java, adapting the formalisation and logics to these new abstractions (\ref{del:formal2}). The \emph{third} phase refines this approach to take into account the semantics of the libraries used in distributed data analytics systems, using hierarchical logics to support reasoning across levels of abstraction(\ref{del:formal3}). This will give us a unifying formalism for the rigorous verification of the security contracts across layers.
\UCM leads this task with their expertise in specifying contracts at different levels and programming languages. \SA and \SCCHshort will work closely on the formalisation and extension of \textsf{eKnows}. \IBMshort and \SOPRAshort will provide expertise in identification of security vulnerabilities and use cases.
\end{Task}

\begin{Task}
%\TaskTitle{Formal Verification and Reasoning about Refactorings}
\TaskTitle{Formal Reasoning about Refactorings}
\TaskParticipant{USTAN}{5}
\TaskParticipant{SCCH}{4}
\TaskParticipant{UCM}{3}
\TaskStart{4}
\TaskEnd{34}
\TaskResults{%
\ref{del:formal1},
\ref{del:formal2},
\ref{del:formal3}
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:formalverif}

% VJ : Old Version
%In \theTask, we will formalise extracted contracts from source code using concurrent ASMs, and define a semantics over ASM runs using the true-concurrent model of event structures. 
%We will formalise abstraction/refinement as a bidirectional transformation between ASM specifications across layers, and use them to define 
%security-preserving transformations as well as a notion of behavioural equivalence between code fragments (within/between languages), investigating how to formalise self-healing in this way.
%The formalisation and verification of the refactorings from~\ref{task:statichealing}, in particular when these introduce the security patterns from~\ref{task:patterns}, will enable developers to gain confidence that the
%refactorings do not change the intended behaviour and in addition are given the guarantee that these satisfy the security requirements imposed. We will initially focus on a tractable subset of the target language, in order to demonstrate functional  equivalence between the original program and the refactored output, based on the identified semantics representation. This will involve identifying a representation of the semantics for the subset of the target language and defining an equivalence relation between the original and refactored programs. 
%%We will use our experience with theorem provers for this task.
%We will define a logic to capture properties of interest  including security properties (based on distributed (stochastic) temporal logics or similar separation
%logics) and privacy norms (FOL). The stochastic element of such logics will be important to reason on measurable properties (see ~\ref{task:RequirementsSastAssessment}).
%We will explore how combining theorem provers and SMT solvers allows us to prove the correctness of behavioural equivalences on the one side, and search for a subset of traces of execution that satisfy certain criteria including security properties and privacy norms.
%This task will proceed in three phases. The first phase will concern the formal semantics of a tractable subset 
%of the programming languages used, and will explore notions of behavioural equivalence, abstraction/refinement as bidirectional transformations between code at the same layer, and the required logic for verification (\ref{del:formal1}). In the second phase we will expand the notion of transformations across layers, expanding all formal notions of equivalence, trace of execution, logic and satisfaction in this way  (\ref{del:formal2}). The final phase will lead to an integrated approach and the verification of the correctness of the transformations in the context of our distributed data analytics systems (\ref{del:formal3}) focusing specifically on expressing and verifying privacy concerns.
%\SA leads this task given their expertise in refactoring, formal verification and distributed logics. \SA will work closely with \SCCHshort on the formal verification elements, and with \UCM on code refactorings.

\theTask\ defines the semantics of security contracts from \ref{task:contracts} using concurrent ASMs. To reason across layers of abstraction we define %defining %formalise abstraction/refinement as a 
 bidirectional transformations between ASMs %across layers and 
and security-preserving transformations. We will also define a notion of behavioural equivalence between code fragments (within/between languages). Theorem provers and SMT solvers will be combined to prove the correctness of these equivalences, and for verifying refactorings
from~\ref{task:statichealing}, adding confidence that the refactorings do not change the intended behaviour and 
\taskbreak 
that we can find one that satisfies the security requirements imposed. 
% VJ: Why is defining logic to capture properties of interest done in this task and not in T4.1?
%%%%We will define a logic (based on e.g.~distributed stochastic temporal logics) to capture security properties and %%%%privacy norms (FOL) and search for execution traces that satisfy these properties and norms. 
This task will proceed in three phases. In the \emph{first} phase, we define notions of behavioural equivalence and abstraction/refinement 
%and develop the required logic for verification of a tractable subset of the programming languages used 
(\ref{del:formal1}). In the \emph{second} phase we extend the notion of transformations across layers, expanding all formal notions of equivalence, trace of execution, and so on
%logic and satisfaction, 
(\ref{del:formal2}). The \emph{final} phase will lead to an integrated approach and the verification of the correctness of the transformations in the context of our distributed data analytics systems (\ref{del:formal3}) focusing specifically on expressing and verifying privacy concerns with FOL.
\SA leads this task given their expertise in refactoring, logics and formal verification, theorem provers and SMT solvers. 
%and distributed logics. 
\SA will work closely with \SCCHshort on formal verification, and with \UCM on code refactorings.

\end{Task}

%\begin{Task}
%	\TaskTitle{Correctness of Refactorings for Self-Healing}
%	\TaskParticipant{USTAN}{24}
%	\TaskParticipant{SCCH}{1}
%	\TaskParticipant{IBM}{1}
%	\TaskStart{1}
%	\TaskEnd{34}
%	\TaskResults{%
%		%%\ref{del:model1}
%	}
%	\TaskHeader{}
%	\tasklabel{task:runtimehealing}
%In \theTask, we will formalise the refactorings from~\ref{task:statichealing} that introduce the security patterns (from~\ref{task:patterns})  developing mechanised proofs of their functional correctness. This will improve confidence to the end-user that the refactorings will not change the functional behaviour of the programs being refactored. Proofs that the refactorings increase the security properties of the program will not be handled here, but instead given in T4.X.
%
%The mechanisations will focus on a tractable subset of the target language, in order to demonstrate functional  equivalence between the original program and the refactored output, based on the identified semantics representation. This will involve identifying a representation of the semantics for the subset of the target language and defining an equivalence relation between the original and refactored programs. We will provide mechanised proofs in the form of implementations in a dependently typed language, such as Idris.
%
%This task will proceed in a number of phases. In the \emph{first} phase, we will identify the formal semantics of a tractable subset of the target language. In the \emph{second} phase, we will define an equivalence relation between the original program and the refactored output w.r.t. to the semantics identified in the first phase. Finally, in the \emph{third} phase will produce mechanised proofs of functional correctness for number of the refactorings produced  in~\ref{task:statichealing}, w.r.t. to the semantics and equivlence relations from the previous phases.
%
%\end{Task}


%Chris' text
%In \theTask, we will formalise the refactorings from TX.X showing proof sketches of their correctness. We will identify a well-formed semantics for a subset of the target language and show an equivalence relation for a selected number of refactorings over this language. The proof sketches will be mechanised, using a theorem prover such as COQ or Isabelle, or by using a dependent typed approach, such as Idris. The proofs of correctness will show that the refactored program is (functionally) equivalent to the original, w.r.t. to the functional semantics defined. 

\begin{Task}
%\TaskTitle{Attack Models and Security Repairability of Proof Obligations}
\TaskTitle{Proof Obligations}
\TaskParticipant{SCCH}{5}
\TaskParticipant{USTAN}{5}
\TaskParticipant{IBM}{1}
\TaskStart{3}
\TaskEnd{34}
\TaskResults{%
\ref{del:formal1},
\ref{del:formal2},
\ref{del:formal3}
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:attackmodels}

%\theTask\ will define classes of security contract requirements for distributed data analytics applications, and formalise repair proof obligations for ASMs with respect to these requirements. In a first step towards this, the industrial use cases will be analysed for security threats from two different angles concerning secrets in the data and processes that are to be protected, and anticipated actions of potential attackers. Regarding secrets this will be formalised through static and dynamic constraints, for which subformulae are identified that by themselves do not contain any secrets. Regarding potential attacks, attacker models for each of the security constraints will be developed. In a second step, the one-step logic for reasoning about concurrent systems of ASM specifications will be used to formalise the security constraints. In addition, for each identified attack the anticipated approach of the attacker will be specified by a corresponding ASM. This task will proceed in phases: the first phase will look at security threats on processes (\ref{del:formal1}),
%the second phase will look at security threats on data (\ref{del:formal2}) and the third phase will explore
%more complex security and privacy threats affecting multiple layers, data and processes.
%\SCCHshort will lead this task working closely with  \SA on all aspects. \IBMshort will provide their expertise on how to identify and repair vulnerabilities.

\theTask{} will define classes of security contract requirements for distributed data analytics applications, and formalise repair proof obligations for ASMs with respect to these requirements. We will address %two kinds of 
threats such as \emph{secrets in the data and processes that are to be protected}, for which proof obligations will be formalised through static and dynamic constraints and identification of secret-free subformulae and \emph{anticipated actions of potential attackers}, developing attacker models for each of the security constraints. A one-step logic for reasoning about concurrent  ASMs will be used to formalise security constraints. In addition, for each identified attack the anticipated approach of the attacker will be specified by a corresponding ASM. This task will proceed in three phases. The \emph{first} phase will look at security threats on processes (\ref{del:formal1}), the \emph{second} phase will look at security threats on data (\ref{del:formal2}) and the \emph{third} phase will explore more complex security and privacy threats affecting multiple layers, data and processes. \SCCHshort will lead this task working closely with \SA on all aspects. \IBMshort will provide their expertise on identifying vulnerabilities.

\end{Task}


%\begin{Task}
%\TaskTitle{Dynamic Analysis of Security Contracts}%% Added to Task 1
%\TaskParticipant{UOD}{1}
%
%\TaskStart{1}
%\TaskEnd{27}
%\TaskResults{%
%%\ref{del:model1}
%}
%\TaskHeader{}
%\tasklabel{task:dyncontracts}
%
%In \theTask, we will focus on the dynamic analysis of security contracts for
%vulnerabilities that cannot be formally verified without running the software component.
%%cannot be proved by formal verification without running the software component.
%\end{Task}



\begin{Task}
\TaskTitle{Analysis-based Risk Assessment for Source Code Security Breaches}
\TaskParticipant{UCM}{2}
\TaskParticipant{IBM}{2}
\TaskParticipant{YAG}{2}
\TaskParticipant{USTAN}{1}
\TaskParticipant{SOPRA}{1}

\TaskStart{3}
\TaskEnd{30}
\TaskResults{%
\ref{del:formal1},
\ref{del:formal2},
\ref{del:formal3}
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:ContractsSastAssessment}

%Complementing the formal verification of security contracts, \theTask, will provide a novel way to assess the risk that a security contract is not met by an application in the presence of 
%uncertainty. %, based on uncertain information. This will include:
%Risk assessment under uncertainty will require i) the parsing and analysis of security contracts; ii) the mapping of the security contracts with the potentially impacted source code;
%iii) designing an application programming interface between formal verification and static analysis to collect and include formally verified properties of the source code in the vulnerability assessment algorithms;
%iv) explore overall risk assessment that a security contract is not met, integrating formally proven properties to static analysis outputs and machine learning detected uncertain security properties. 
%The task will proceed in phases according to the steps above and in increasing complexity on the security contracts and levels of uncertainty in \ref{del:formal1} and \ref{del:formal2}, and explored with the use cases extensively in 
%\ref{del:formal3}.
%\UCM will lead the task given their expertise in security contracts.  \IBMshort, \YAGshort and \SOPRAshort will provide their practical experience and security expertise. \SA will help with the formal verification.

\theTask{} complements the formal verification of security contracts with mechanisms to assess the risk of contracts not being met in the presence of uncertainty. 
Assessment is done by parsing security contracts and comparing their formally proven properties to the output of static analysis for vulnerabilities and machine-learning based methods to detect uncertain security properties. The task will proceed in three phases, with each phase considering security contracts of increasing complexity as developed in T4.1, and resulting in deliverables~\ref{del:formal1},~\ref{del:formal2} and \ref{del:formal3}. \UCM will lead the task given their expertise in security contracts.  \IBMshort, \YAGshort and \SOPRAshort will provide practical experience and security expertise. \SA will help with the verification of uncertainties.
\end{Task}


\begin{Task}
\TaskTitle{Metric-based Assessment of security requirements} % based on CVSS metrics}
\TaskStart{6}
\TaskEnd{33}
\TaskParticipant{YAG}{4}
\TaskParticipant{USTAN}{2}
\TaskParticipant{IBM}{1}
\TaskParticipant{UCM}{1}
\TaskParticipant{SOPRA}{0.5}

\TaskStart{1}
\TaskEnd{27}
\TaskResults{%
\ref{del:formal1},
\ref{del:formal2},
\ref{del:formal3}
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:RequirementsSastAssessment}

%As another approach to extend formal verification of security contracts, in \theTask\ we will explore and prototype a semi-automated assessment of functional security requirements, using the CVSS metrics such as confidentiality, integrity and availability.
%We will develop a domain specific language to capture the functionalities description, allocate requirements and map with the source code. Each vulnerability which breaks a requirement will be identified and allocated decision making information for the user.
%The use cases will provide realistic examples to explore the assessment of the CVSS metrics.
%The task will proceed in phases similarly to others in this WP. The first phase will consider security contracts and vulnerability assessment within one layer only (\ref{del:formal1}). The second phase will add more complex contracts and vulnerabilities across layers (\ref{del:formal2}). The third phase will focus specifically on vulnerabilities over distributed data analytics systems (\ref{del:formal3}).
%\YAGshort will lead this task given their expertise in security assessment. \SA will contribute with their expertise in the verification of stochastic properties, and \UCM with their expertise in C++ and contracts. \IBMshort and \SOPRAshort will provide advice with their  practical experience in security vulnerability detection.

\theTask{} will further complement formal verification of security contracts by developing a semi-automated assessment of functional security requirements, using the CVSS metrics such as confidentiality, integrity and availability. We will develop a domain specific language to capture the functionalities description, allocate requirements and map to the source code. Each vulnerability which breaks a requirement will be identified and allocated decision making information for the user.
The task will proceed in three phases, considering security contracts and vulnerability assessment within one layer only (\ref{del:formal1}), more complex contracts and vulnerabilities across layers (\ref{del:formal2}) and focusing specifically on vulnerabilities over distributed data analytics systems (\ref{del:formal3}).
\YAGshort will lead this task given their expertise in security assessment. \SA will contribute with their expertise in the verification of stochastic properties, and \UCM with their expertise in C++ and contracts. \IBMshort and \SOPRAshort will provide advice with their practical experience in security vulnerability detection.

\end{Task}


\begin{WPDeliverables}
  \begin{compactitem}
  \item \ref{del:formal1} (Month 11) : Report on Formal Verification of Security \& Privacy for Distributed Data Analytics (DDA)
  %on Formal Mechanisms for Verifying Security Properties on Private Clouds
\item \ref{del:formal2} (Month 24) : 
Refined report on Formal Verification of Security \& Privacy for DDA 
%Report on Formal Mechanisms for Verifying Security Properties on Public Clouds 
\item \ref{del:formal3} (Month 34) : Final report on Integrated Verification and Assessment of Security \& Privacy for DDA 
\end{compactitem}
\end{WPDeliverables}
\end{Workpackage}
