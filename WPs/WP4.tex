\addtocounter{wpno}{1}
\begin{Workpackage}{\thewpno}
\wplabel{wp:securityContracts}
\WPTitle{\wpname{\thewpno}}
\WPStart{Month 1}
\WPParticipant{USTAN}{17}
\WPParticipant{UCM}{14}
\WPParticipant{SCCH}{12}
\WPParticipant{YAG}{6}
\WPParticipant{IBM}{5}
\WPParticipant{SOPRA}{2.5}


\begin{WPObjectives}
The objectives of \theWP{} are to:
\begin{compactitem}
%% Why just embedded? Are these domains correct? KH
\item Develop a formal high-level multi-level specification language; % able to capture different levels of abstraction; %and security contracts
\item Define abstraction/refinement as a bidirectional transformation between specifications across levels;
% How is distribution considered?
%BOTH for source code and code patterns that represent known vulnerabilities 
%and relate different levels of abstraction (from models to code)
\item Define a notion of behavioural equivalence between code fragments (within/between language(s)), able to capture refactorings, and suitable to formalise security and privacy-preserving equivalences;
\item Define a logic to capture properties of interest  %interpreted over (distributed) traces of execution; 
including security properties and privacy norms;
\item Develop an integrated verification framework, including theorem provers and SMT solvers, to prove the correctness of the above and 
%, and capable of searching for (a subset of) traces of execution that satisfy certain parameters (meet a certain threshold for instance);
 explore an interplay between runtime verification and exhaustive formal verification;
 \item  Verify the correctness of the mechanisms from WP2 for vulnerability detection and self-healing.
%\item Develop a novel mechanism for automated vulnerability localisation, containment, recovery and repair.

\end{compactitem}

%Needs to be related to WP2 and vulnerabilities 
\end{WPObjectives}

\begin{WPDescription}
\theWP{} explores how rigorous formal methods can %continuously 
provide systematic guarantees of security and privacy in 
software systems at different levels of abstraction.
%our software systems.
%Establishing whole-system security for end-user software is crucial but particularly challenging for distributed systems.
%The scale of distributed systems requires the development of methods for security assurance that are modular, compositional and 
%incremental. As these systems evolve over time, and are often built using existing service components exporting an API that can be used by components developed later,  
%security cannot be verified once but has to be done incrementally as the systems evolve.
%We need  to specify and ensure the security of the whole system and not just individual components or abstraction layers within a system. 
We define the abstractions to present to the programmer, provided by the operating system, architecture, and so on (Task~\ref{task:contracts}), and introduce a specification language to capture the assumptions and guarantees of abstraction layers to facilitate reasoning about security across abstraction levels.
% (Task~\ref{task:formalverif}). 
The abstractions should expose security properties in a form understandable to (non-security specialist) programmers. We adopt Abstract State Machines (ASMs), given our experience in extracting ASMs from source code automatically. 
The ability to move between layers with this approach and target the extraction of vulnerabilities from code for verification at higher levels will be key.
Similarly, we will define this as a model for our functionally equivalent code, aka refactorings, and automatically search for alternative refactorings such that their security guarantees are preserved, or conversely, detected vulnerabilities are avoided (Task~\ref{task:formalverif}).
Concerning privacy, complementary to the work on privacy-preserving machine learning algorithms of WP3, we will consider privacy expectations expressed using context-relative informational norms, formalised in logic (e,g. FOL) and automatically checked across traces of execution (Task~\ref{task:formalverif}).  
By explicitly modelling the computer system and the abilities of adversaries, formal methods can prove that the computer system is secure against all possible attacks (up to modelling assumptions). This provides high assurance of system security, even against as-yet-unknown attacks (Task~\ref{task:attackmodels}).
%as formal approaches in practice with the use of tools such as the ones from IBM, static analyser from YAG and code extractor from SCCH. 
\theWP{} explores the integration of formal methods with the practical techniques from WP2, supports the tools from WP6 and is evaluated throughout with the use cases described in WP7.
We will further investigate the gaps or intersections between some of these approaches, enable their interoperability and hence avoid missing potential vulnerabilities at different layers of abstraction (%Task~\ref{task:dyncontracts} and 
Task~\ref{task:ContractsSastAssessment}). 
For functional security requirements we will explore the use of metrics such as confidentiality, integrity and availability to assess them (Task~\ref{task:RequirementsSastAssessment}).
\end{WPDescription}


\begin{Task}
\TaskTitle{Security Contracts support and specification}
\TaskParticipant{UCM}{8}
\TaskParticipant{USTAN}{4}
\TaskParticipant{SCCH}{4} 
\TaskParticipant{IBM}{1}
\TaskParticipant{SOPRA}{1}
\TaskStart{1}
\TaskEnd{34}
\TaskResults{%
\ref{del:formal1},
\ref{del:formal2},
\ref{del:formal3}
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:contracts}

In \theTask, we define mechanisms to represent security contracts
in such a way that they can be mapped to concrete syntax in different
programming languages. Conversely, we will enable the extraction of those contracts
from existing source code and  allow developers to refine them iteratively. The contract extraction will be formalised with ASMs.
%approaches where contracts can be refined by developers. 
This task will proceed in three phases.
The first phase will focus on the representation of security contracts and add to the \textsf{eKnows} module for semi-automated extraction of ASMs from source code (which currently works for Java code) the capability to extract ASMs from C++ code. Since the module is based on abstract syntax trees and designed for multi-language reverse engineering, this first step is relatively straightforward.
We will provide initial formalisation of the security contracts in (temporal) logics for ASMs and interpreted over the code extracted ASMs (\ref{del:formal1}).
%(\ref{del:formal1}).
%can be completed in a relatively short time. 
The second phase will focus on more sophisticated higher-level abstractions
for the different programming languages considered and identified programming patterns. The formalisation and logics used will be adapted to the new abstractions as required (\ref{del:formal2}).
The third phase will refine the previous approach to
take into account the semantics of the libraries used in the targeted distributed data analytics systems.
%as well as that of its common programming patterns. 
We envisage a set of hierarchical logics such that reasoning across levels of abstraction is supported.
%The security contracts can then be expressed in the logics for ASMs (and its planned temporal extension) over the extracted ASMs, at the different levels of abstraction required. 
This will give us a unifying formalism for the rigorous verification of the envisaged security contracts across multiple layers. This will be reported in \ref{del:formal3}.
\UCM leads this task with their expertise in specifying contracts at different levels and programming languages. \SA and \SCCHshort will work closely on the formalisation and extension of \textsf{eKnows} combining their expertise in semantics, distributed logics and ASMs. \IBMshort and \SOPRAshort will provide expertise on the identification of security vulnerabilities. % are identified in practice.
%In addition, we will focus on the dynamic analysis of security contracts for
%vulnerabilities that cannot be formally verified without running the software component. 
%Note that C++ and Java code will just be refinements of the extracted ASMs. Plus, given the abstraction mechanism used for the ASMs extraction, we will already have the mapping to the concrete syntax of the programming languages.
\end{Task}

\begin{Task}
\TaskTitle{Formal Verification and Reasoning about Refactorings}
\TaskParticipant{USTAN}{5}
\TaskParticipant{SCCH}{4}
\TaskParticipant{UCM}{3}
\TaskStart{4}
\TaskEnd{34}
\TaskResults{%
\ref{del:formal1},
\ref{del:formal2},
\ref{del:formal3}
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:formalverif}

In \theTask, we will formalise extracted contracts from source code using concurrent ASMs, and define a semantics over ASM runs using the true-concurrent model of event structures. 
We will formalise abstraction/refinement as a bidirectional transformation between ASM specifications across layers, and use them to define 
security-preserving transformations as well as a notion of behavioural equivalence between code fragments (within/between languages), investigating how to formalise self-healing in this way.
The formalisation and verification of the refactorings from~\ref{task:statichealing}, in particular when these introduce the security patterns from~\ref{task:patterns}, will enable developers to gain confidence that the
refactorings do not change the intended behaviour and in addition are given the guarantee that these satisfy the security requirements imposed. We will initially focus on a tractable subset of the target language, in order to demonstrate functional  equivalence between the original program and the refactored output, based on the identified semantics representation. This will involve identifying a representation of the semantics for the subset of the target language and defining an equivalence relation between the original and refactored programs. 
%We will use our experience with theorem provers for this task.
We will define a logic to capture properties of interest  including security properties (based on distributed (stochastic) temporal logics or similar separation
logics) and privacy norms (FOL). The stochastic element of such logics will be important to reason on measurable properties (see ~\ref{task:RequirementsSastAssessment}).
We will explore how combining theorem provers and SMT solvers allows us to prove the correctness of behavioural equivalences on the one side, and search for a subset of traces of execution that satisfy certain criteria including security properties and privacy norms.
This task will proceed in three phases. The first phase will concern the formal semantics of a tractable subset 
of the programming languages used, and will explore notions of behavioural equivalence, abstraction/refinement as bidirectional transformations between code at the same layer, and the required logic for verification (\ref{del:formal1}). In the second phase we will expand the notion of transformations across layers, expanding all formal notions of equivalence, trace of execution, logic and satisfaction in this way  (\ref{del:formal2}). The final phase will lead to an integrated approach and the verification of the correctness of the transformations in the context of our distributed data analytics systems (\ref{del:formal3}) focusing specifically on expressing and verifying privacy concerns.
\SA leads this task given their expertise in refactoring, formal verification and distributed logics. \SA will work closely with \SCCHshort on the formal verification elements, and with \UCM on code refactorings.

\end{Task}

%\begin{Task}
%	\TaskTitle{Correctness of Refactorings for Self-Healing}
%	\TaskParticipant{USTAN}{24}
%	\TaskParticipant{SCCH}{1}
%	\TaskParticipant{IBM}{1}
%	\TaskStart{1}
%	\TaskEnd{34}
%	\TaskResults{%
%		%%\ref{del:model1}
%	}
%	\TaskHeader{}
%	\tasklabel{task:runtimehealing}
%In \theTask, we will formalise the refactorings from~\ref{task:statichealing} that introduce the security patterns (from~\ref{task:patterns})  developing mechanised proofs of their functional correctness. This will improve confidence to the end-user that the refactorings will not change the functional behaviour of the programs being refactored. Proofs that the refactorings increase the security properties of the program will not be handled here, but instead given in T4.X.
%
%The mechanisations will focus on a tractable subset of the target language, in order to demonstrate functional  equivalence between the original program and the refactored output, based on the identified semantics representation. This will involve identifying a representation of the semantics for the subset of the target language and defining an equivalence relation between the original and refactored programs. We will provide mechanised proofs in the form of implementations in a dependently typed language, such as Idris.
%
%This task will proceed in a number of phases. In the \emph{first} phase, we will identify the formal semantics of a tractable subset of the target language. In the \emph{second} phase, we will define an equivalence relation between the original program and the refactored output w.r.t. to the semantics identified in the first phase. Finally, in the \emph{third} phase will produce mechanised proofs of functional correctness for number of the refactorings produced  in~\ref{task:statichealing}, w.r.t. to the semantics and equivlence relations from the previous phases.
%
%\end{Task}


%Chris' text
%In \theTask, we will formalise the refactorings from TX.X showing proof sketches of their correctness. We will identify a well-formed semantics for a subset of the target language and show an equivalence relation for a selected number of refactorings over this language. The proof sketches will be mechanised, using a theorem prover such as COQ or Isabelle, or by using a dependent typed approach, such as Idris. The proofs of correctness will show that the refactored program is (functionally) equivalent to the original, w.r.t. to the functional semantics defined. 

\begin{Task}
\TaskTitle{Attack Models and Security Repairability of Proof Obligations}
\TaskParticipant{USTAN}{5}
\TaskParticipant{SCCH}{4}
\TaskParticipant{IBM}{1}
\TaskStart{3}
\TaskEnd{34}
\TaskResults{%
\ref{del:formal1},
\ref{del:formal2},
\ref{del:formal3}
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:attackmodels}

The aim of \theTask\ is to define classes of security contract requirements for distributed data analytics applications, and formalise repair proof obligations for ASMs with respect to these security contract requirements. In a first step towards this, the industrial use cases will be analysed for security threats from two different angles concerning secrets in the data and processes that are to be protected, and anticipated actions of potential attackers. Regarding secrets this will be formalised through static and dynamic constraints, for which subformulae are identified that by themselves do not contain any secrets. Regarding potential attacks, attacker models for each of the security constraints will be developed. In a second step, the one-step logic for reasoning about concurrent systems of ASM specifications will be used to formalise the security constraints. In addition, for each identified attack the anticipated approach of the attacker will be specified by a corresponding ASM. This task will proceed in phases: the first phase will look at security threats on processes (\ref{del:formal1}),
the second phase will look at security threats on data (\ref{del:formal2}) and the third phase will explore
more complex security and privacy threats affecting multiple layers, data and processes.
\SA will lead this task working closely with \SCCHshort on all aspects. \IBMshort will provide their expertise on how to identify and repair vulnerabilities.
\end{Task}


%\begin{Task}
%\TaskTitle{Dynamic Analysis of Security Contracts}%% Added to Task 1
%\TaskParticipant{UOD}{1}
%
%\TaskStart{1}
%\TaskEnd{27}
%\TaskResults{%
%%\ref{del:model1}
%}
%\TaskHeader{}
%\tasklabel{task:dyncontracts}
%
%In \theTask, we will focus on the dynamic analysis of security contracts for
%vulnerabilities that cannot be formally verified without running the software component.
%%cannot be proved by formal verification without running the software component.
%\end{Task}



\begin{Task}
\TaskTitle{Analysis-based Risk Assessment for Source Code Security Breaches}
\TaskParticipant{UCM}{2}
\TaskParticipant{IBM}{2}
\TaskParticipant{YAG}{2}
\TaskParticipant{USTAN}{1}
\TaskParticipant{SOPRA}{1}

\TaskStart{3}
\TaskEnd{30}
\TaskResults{%
\ref{del:formal1},
\ref{del:formal2},
\ref{del:formal3}
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:ContractsSastAssessment}

Complementing the formal verification of security contracts, \theTask, will provide a novel way to assess the risk that a security contract is not met by an application in the presence of 
uncertainty. %, based on uncertain information. This will include:
Risk assessment under uncertainty will require i) the parsing and analysis of security contracts; ii) the mapping of the security contracts with the potentially impacted source code;
iii) designing an application programming interface between formal verification and static analysis to collect and include formally verified properties of the source code in the vulnerability assessment algorithms;
iv) explore overall risk assessment that a security contract is not met, integrating formally proven properties to static analysis outputs and machine learning detected uncertain security properties. 
The task will proceed in phases according to the steps above and in increasing complexity on the security contracts and levels of uncertainty in \ref{del:formal1} and \ref{del:formal2}, and explored with the use cases extensively in 
\ref{del:formal3}.
\UCM will lead the task given their expertise in security contracts.  \IBMshort, \YAGshort and \SOPRAshort will provide their practical experience and security expertise. \SA will help with the formal verification.
%begin{itemize}
%\item The parsing and analysis of the security contracts; %resulting from present \theWP / T4.1 and T4.2
 %   \item Mapping of the security contracts with the potentially impacted source code;
  %  \item Designing an application programming interface between formal verification and static analysis to collect and include formally verified properties of the source code in the vulnerability assessment algorithms;
  %  \item Explore overall risk assessment that a security contract is not met, integrating formally proven properties to static analysis outputs and machine learning detected uncertain security properties;
%\end{itemize}

\end{Task}


\begin{Task}
\TaskTitle{Metric-based Assessment of security requirements} % based on CVSS metrics}
\TaskStart{6}
\TaskEnd{33}
\TaskParticipant{YAG}{4}
\TaskParticipant{USTAN}{2}
\TaskParticipant{IBM}{1}
\TaskParticipant{UCM}{1}
\TaskParticipant{SOPRA}{0.5}

\TaskStart{1}
\TaskEnd{27}
\TaskResults{%
\ref{del:formal1},
\ref{del:formal2},
\ref{del:formal3}
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:RequirementsSastAssessment}
As another approach to extend formal verification of security contracts, in \theTask\ we will explore and prototype a semi-automated assessment of functional security requirements, using the CVSS metrics such as confidentiality, integrity and availability.
We will develop a domain specific language to capture the functionalities description, allocate requirements and map with the source code. Each vulnerability which breaks a requirement will be identified and allocated decision making information for the user.
The use cases will provide realistic examples to explore the assessment of the CVSS metrics.
The task will proceed in phases similarly to others in this WP. The first phase will consider security contracts and vulnerability assessment within one layer only (\ref{del:formal1}). The second phase will add more complex contracts and vulnerabilities across layers (\ref{del:formal2}). The third phase will focus specifically on vulnerabilities over distributed data analytics systems (\ref{del:formal3}).
\YAGshort will lead this task given their expertise in security assessment. \SA will contribute with their expertise in the verification of stochastic properties, and \UCM with their expertise in C++ and contracts. \IBMshort and \SOPRAshort will provide advice with their  practical experience in security vulnerability detection.

\end{Task}


\begin{WPDeliverables}
  \begin{compactitem}
  \item \ref{del:formal1} (Month 11) : Report on Formal Verification of Security \& Privacy for Distributed Data Analytics
  %on Formal Mechanisms for Verifying Security Properties on Private Clouds
\item \ref{del:formal2} (Month 24) : 
Refined Formal Verification of Security \& Privacy for Distributed Data Analytics 
%Report on Formal Mechanisms for Verifying Security Properties on Public Clouds 
\item \ref{del:formal3} (Month 34) : Final report on Integrated Verification and Assessment of Security \& Privacy for Distributed Data Analytics 
\end{compactitem}
\end{WPDeliverables}
\end{Workpackage}
