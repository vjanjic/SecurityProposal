\addtocounter{wpno}{1}
\begin{Workpackage}{\thewpno}
\wplabel{wp:securityContracts}
\WPTitle{\wpname{\thewpno}}
\WPStart{Month 1}
\WPParticipant{USTAN}{1}
\WPParticipant{UOD}{1}
\WPParticipant{SCCH}{1}
\WPParticipant{IBM}{1}
\WPParticipant{UCM}{1}
\WPParticipant{YAG}{1}


\begin{WPObjectives}
The objectives of \theWP{} are to:
\begin{compactitem}
%% Why just embedded? Are these domains correct? KH
\item Develop a formal high-level multi-level specification language; % able to capture different levels of abstraction; %and security contracts
\item Define abstraction/refinement as a bidirectional transformation between specifications across levels;
% How is distribution considered?
%BOTH for source code and code patterns that represent known vulnerabilities 
%and relate different levels of abstraction (from models to code)
\item Define a notion of behavioural equivalence between code fragments (within/between language(s)), able to capture refactorings, and suitable to formalise security and privacy-preserving equivalences;
\item Define a logic to capture properties of interest  %interpreted over (distributed) traces of execution; 
including security properties and privacy norms;
\item Develop an integrated verification framework, including theorem provers and SMT solvers, to prove the correctness of the above and 
%, and capable of searching for (a subset of) traces of execution that satisfy certain parameters (meet a certain threshold for instance);
 explore an interplay between runtime verification and exhaustive formal verification;
\item Develop a novel mechanism for automated vulnerability localisation, containment, recovery and repair.

\end{compactitem}

%Needs to be related to WP2 and vulnerabilities 
\end{WPObjectives}

\begin{WPDescription}
\theWP{} explores how rigorous formal methods can %continuously 
provide systematic guarantees of security and privacy in 
software systems at different levels of abstraction.
%our software systems.
%Establishing whole-system security for end-user software is crucial but particularly challenging for distributed systems.
%The scale of distributed systems requires the development of methods for security assurance that are modular, compositional and 
%incremental. As these systems evolve over time, and are often built using existing service components exporting an API that can be used by components developed later,  
%security cannot be verified once but has to be done incrementally as the systems evolve.
%We need  to specify and ensure the security of the whole system and not just individual components or abstraction layers within a system. 
We define the abstractions to present to the programmer, provided by the operating system, architecture, and so on (Task~\ref{task:contracts}), and introduce a specification language to capture the assumptions and guarantees of abstraction layers to facilitate reasoning about security across abstraction levels.
% (Task~\ref{task:formalverif}). 
The abstractions should expose security properties in a form understandable to (non-security specialist) programmers. We adopt Abstract State Machines (ASMs), given our experience in extracting ASMs from source code automatically. 
The ability to move between layers with this approach and target the extraction of vulnerabilities from code for verification at higher levels will be key.
Similarly, we will define this as a model for our functionally equivalent code, aka refactorings, and automatically search for alternative refactorings such that their security guarantees are preserved, or conversely, detected vulnerabilities are avoided (Task~\ref{task:formalverif}).
Concerning privacy, complementary to the work on privacy-preserving machine learning algorithms of WP3, we will consider privacy expectations expressed using context-relative informational norms, formalised in logic (e.,g., FOL) and automatically checked across traces of execution (Task~\ref{task:formalverif}).  
By explicitly modelling the computer system and the abilities of adversaries, formal methods can prove that the computer system is secure against all possible attacks (up to modelling assumptions). This provides high assurance of system security, even against as-yet-unknown attacks (Task~\ref{task:attackmodels}).
%as formal approaches in practice with the use of tools such as the ones from IBM, static analyser from YAG and code extractor from SCCH. 
\theWP{} explores the integration of formal methods with the practical techniques from WP2, supports the tools from WP6 and is evaluated throughout with the use cases described in WP7.
We will further investigate the gaps or intersections between some of these approaches, enable their interoperability and hence avoid missing potential vulnerabilities at different layers of abstraction (%Task~\ref{task:dyncontracts} and 
Task~\ref{task:ContractsSastAssessment}). 
For functional security requirements we will explore the use of metrics such as confidentiality, integrity and availability to assess them (Task~\ref{task:RequirementsSastAssessment}).


\end{WPDescription}


\begin{Task}
\TaskTitle{Security Contracts support and specification}
\TaskParticipant{UCM}{1}

\TaskStart{1}
\TaskEnd{27}
\TaskResults{%
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:contracts}

In \theTask, we define mechanisms to represent security contracts
in such a way that they can be mapped to concrete syntax in different
programming languages. We will also support the extraction of those contracts
from existing source code allowing iterative approaches where contracts
are refined by developers.
In this task we will first add to the \textsf{eKnows} module for semi-automated extraction of ASMs from source code (which currently works for Java code) the capability to extract ASMs from C++ code. Since the module is based on abstract syntax trees and designed for multi-language reverse engineering, this first step is relatively straightforward.
%can be completed in a relatively short time. 
We will then further develop the module to perform more sophisticated higher-level abstractions, taking into account the semantics of the libraries used in the targeted distributed data analytics systems as well as that of its common programming patterns. The security contracts can then be expressed in the logics for ASMs (and its planned temporal extension) over the extracted ASMs, at the different levels of abstraction required. This will give us a unifying formalism for the rigorous verification of the envisaged security contracts.  
%In addition, we will focus on the dynamic analysis of security contracts for
%vulnerabilities that cannot be formally verified without running the software component. 
%Note that C++ and Java code will just be refinements of the extracted ASMs. Plus, given the abstraction mechanism used for the ASMs extraction, we will already have the mapping to the concrete syntax of the programming languages.


\end{Task}

\begin{Task}
\TaskTitle{Formal Verification and Reasoning about Refactorings}
\TaskParticipant{USTAN}{1}

\TaskStart{1}
\TaskEnd{27}
\TaskResults{%
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:formalverif}

In \theTask, we will formalise extracted contracts from source code using concurrent ASMs, and define a semantics over ASM runs using the true-concurrent model of event structures. 
We will formalise abstraction/refinement as a bidirectional transformation between ASM specifications across layers, and use them to define 
security-preserving transformations as well as a notion of behavioural equivalence between code fragments (within/between languages) and refactorings.
We will define a logic to capture properties of interest  including security properties (based on distributed stochastic temporal logics or separation
logic) and privacy norms (FOL).
We will explore how combining theorem provers and SMT solvers allows us to prove the correctness of behavioural equivalences on the one side, and search for a subset of traces of execution that satisfy certain criteria including security properties and privacy norms.

\end{Task}


%Chris' text
%In \theTask, we will formalise the refactorings from TX.X showing proof sketches of their correctness. We will identify a well-formed semantics for a subset of the target language and show an equivalence relation for a selected number of refactorings over this language. The proof sketches will be mechanised, using a theorem prover such as COQ or Isabelle, or by using a dependent typed approach, such as Idris. The proofs of correctness will show that the refactored program is (functionally) equivalent to the original, w.r.t. to the functional semantics defined. 

\begin{Task}
\TaskTitle{Attack Models and Security Repairability of Proof Obligations}
\TaskParticipant{SCCH}{1}

\TaskStart{1}
\TaskEnd{27}
\TaskResults{%
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:attackmodels}

The aim of \theTask\ is to define classes of security contract requirements for distributed data analytics applications, and formalise repair proof obligations for ASMs with respect to these security contract requirements. In a first step towards this, the industrial use cases will be analysed for security threats from two different angles concerning secrets in the data and processes that are to be protected, and anticipated actions of potential attackers. Regarding secrets this will be formalised through static and dynamic constraints, for which subformulae are identified that by themselves do not contain any secrets. Regarding potential attacks, attacker models for each of the security constraints will be developed. In a second step, the one-step logic for reasoning about concurrent systems of ASM specifications will be used to formalise the security constraints. In addition, for each identified attack the anticipated approach of the attacker will be specified by a corresponding ASM.
\end{Task}


%\begin{Task}
%\TaskTitle{Dynamic Analysis of Security Contracts}%% Added to Task 1
%\TaskParticipant{UOD}{1}
%
%\TaskStart{1}
%\TaskEnd{27}
%\TaskResults{%
%%\ref{del:model1}
%}
%\TaskHeader{}
%\tasklabel{task:dyncontracts}
%
%In \theTask, we will focus on the dynamic analysis of security contracts for
%vulnerabilities that cannot be formally verified without running the software component.
%%cannot be proved by formal verification without running the software component.
%\end{Task}



\begin{Task}
\TaskTitle{Analysis-based Risk Assessment for Source Code Security Breaches}
\TaskParticipant{YAG}{1}

\TaskStart{1}
\TaskEnd{27}
\TaskResults{%
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:ContractsSastAssessment}

On the one side, we will use dynamic analysis of security contracts for
vulnerabilities that cannot be formally verified without running the software component.
As a complementary approach to extend formal verification of security contracts, %in \theTask, 
we will provide a novel way to assess the risk that a security contract is not met by an application. This will include:

\begin{itemize}
\item The parsing and analysis of the security contracts; %resulting from present \theWP / T4.1 and T4.2
    \item Mapping of the security contracts with the potentially impacted source code;
    \item Designing an interface between formal verification and static analysis to collect and include formally verified properties of the source code in the vulnerability assessment algorithms;
    \item Explore overall risk assessment that a security contract is not met, integrating formally proven properties to static analysis outputs and machine learning detected uncertain security properties;
    \item Provide remediation proposals to fix vulnerabilities.
\end{itemize}

\end{Task}


\begin{Task}
\TaskTitle{Assessment of security requirements based on CVSS metrics}
\TaskParticipant{YAG}{1}

\TaskStart{1}
\TaskEnd{27}
\TaskResults{%
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:RequirementsSastAssessment}

As another approach to extend formal verification of security contracts, in \theTask\ we can prototype a semi-automated assessment of functional security requirements, using the CVSS metrics such as confidentiality, integrity and availability.
We will develop a domain specific language to capture the functionalities description, allocate requirements and map with the source code. Each vulnerability which breaks a requirement will be identified and allocated decision making information for the user.
\end{Task}


\begin{WPDeliverables}
  \begin{compactitem}
    \item XX
%\item \ref{del:model1} (Month 10): Report on Initial Block-Diagram Modelling, Patterns and Code Synthesis
\end{compactitem}
\end{WPDeliverables}
\end{Workpackage}
