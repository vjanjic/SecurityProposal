\addtocounter{wpno}{1}
\begin{Workpackage}{\thewpno}
\wplabel{wp:securityContracts}
\WPTitle{\wpname{\thewpno}}
\WPStart{Month 1}
\WPParticipant{USTAN}{1}
\WPParticipant{UOD}{1}
\WPParticipant{SCCH}{1}
\WPParticipant{IBM}{1}
\WPParticipant{UCM}{1}
\WPParticipant{YAG}{1}


\begin{WPObjectives}
The objectives of \theWP{} are to:
\begin{compactitem}
%% Why just embedded? Are these domains correct? KH
\item Develop a formal high-level multi-layer specification language; % able to capture different levels of abstraction; %and security contracts
\item Define abstraction/refinement as a bidirectional transformation between specifications across layers;
% How is distribution considered?
%BOTH for source code and code patterns that represent known vulnerabilities 
%and relate different levels of abstraction (from models to code)
\item Define a notion of behavioural equivalence between code fragments (within/between language(s)), able to capture refactorings, and suitable to formalise security and privacy-preserving equivalences;
\item Define a logic to capture properties of interest  %interpreted over (distributed) traces of execution; 
including security properties and privacy norms;
\item Develop an integrated verification framework, including theorem provers and SMT solvers, to prove the correctness of the above and 
%, and capable of searching for (a subset of) traces of execution that satisfy certain parameters (meet a certain threshold for instance);
 explore an interplay between runtime verification and exhaustive formal verification;
\item Develop a novel mechanism for automated vulnerability localisation, containment, recovery and repair.

\end{compactitem}

%Needs to be related to WP4 and vulnerabilities 
\end{WPObjectives}

\begin{WPDescription}
%\theWP{} addresses the problem of solving the world.
\theWP{} explores how rigorous formal methods can  provide systematic guarantees of security and privacy in our software systems.
Establishing whole-system security for end-user software is crucial but particularly challenging for distributed systems.
The scale of distributed systems requires the development of methods for security assurance that are modular, compositional and 
incremental. As these systems evolve over time, and are often built using existing service components exporting an API that can be used by components developed later,  
security cannot be verified once but has to be done incrementally as the systems evolve.
We need  to specify and ensure the security of the whole system and not just individual components or abstraction layers within a system. 
In this WP we define the abstractions to present to the programmer, provided by the operating system, and so on (Task~\ref{task:contracts}), and introduce a specification language to capture the assumptions and guarantees of abstraction layers to facilitate reasoning about security across  layers.
% (Task~\ref{task:formalverif}). 
The abstractions should expose security properties in a form understandable to (non-security specialist) programmers. We adopt Abstract State Machines (ASMs), given our experience in extracting ASMs from source code automatically. 
The ability to move between layers with this approach and target the extraction of vulnerabilities from code for verification at higher levels will be key.
Similarly, we will define this as a model for our functionally equivalent code, aka refactorings, and automatically search for alternative refactorings such that their security guarantees are preserved, or conversely, detected vulnerabilities are avoided (Task~\ref{task:formalverif}).
Concerning privacy, complementary to the work on privacy-preserving machine learning algorithms of WP3, we will consider privacy expectations expressed using context-relative informational norms, formalised in logic (e.,g., FOL) and automatically checked across traces of execution (Task~\ref{task:formalverif}).  
By explicitly modelling the computer system and the abilities of adversaries, formal methods can prove that the computer system is secure against all possible attacks (up to modelling assumptions). This provides high assurance of system security, even against as-yet-unknown attacks (Task~\ref{task:attackmodels}).
%as formal approaches in practice with the use of tools such as the ones from IBM, static analyser from YAG and code extractor from SCCH. 
\theWP{} explores the integration of formal methods with the practical techniques from WP2, supports the tools from WP6 and is evaluated throughout with the use cases described in WP7.
We will further investigate the gaps or intersections between some of these approaches, enable their interoperability and hence avoid missing potential vulnerabilities at different layers of abstraction (Task~\ref{task:dyncontracts} and Task~\ref{task:ContractsSastAssessment}). 



\end{WPDescription}


\begin{Task}
\TaskTitle{Security Contracts support}
\TaskParticipant{UCM}{1}

\TaskStart{1}
\TaskEnd{27}
\TaskResults{%
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:contracts}

In \theTask, we will define the mechanisms to represent security contracts
in such a way that they can be mapped to concrete syntax in different
programming languages. We will also support the extraction of those contracts
from existing source code allowing iterative approaches where contracts
are refined by developers.
\end{Task}

\begin{Task}
\TaskTitle{Formal Verification and Reasoning about Refactorings}
\TaskParticipant{USTAN}{1}

\TaskStart{1}
\TaskEnd{27}
\TaskResults{%
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:formalverif}

In \theTask, we will formalise extracted contracts from source code using concurrent ASMs, and define a semantics over ASM runs using the true-concurrent model of event structures. 
We will formalise abstraction/refinement as a bidirectional transformation between ASM specifications across layers, and use them to define 
security-preserving transformations as well as a notion of behavioural equivalence between code fragments (within/between languages) and refactorings.
We will define a logic to capture properties of interest  including security properties (based on distributed stochastic temporal logics or separation
logic) and privacy norms (FOL).
We will explore how combining theorem provers and SMT solvers allows us to prove the correctness of behavioural equivalences on the one side, and search for a subset of traces of execution that satisfy certain criteria including security properties and privacy norms.

\end{Task}


%Chris' text
%In \theTask, we will formalise the refactorings from TX.X showing proof sketches of their correctness. We will identify a well-formed semantics for a subset of the target language and show an equivalence relation for a selected number of refactorings over this language. The proof sketches will be mechanised, using a theorem prover such as COQ or Isabelle, or by using a dependent typed approach, such as Idris. The proofs of correctness will show that the refactored program is (functionally) equivalent to the original, w.r.t. to the functional semantics defined. 

\begin{Task}
\TaskTitle{Attack Models and Security Repairability of Proof Obligations}
\TaskParticipant{SCCH}{1}

\TaskStart{1}
\TaskEnd{27}
\TaskResults{%
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:attackmodels}

The aim of \theTask\ is to define classes of security contract requirements for distributed data analytics applications, and formalise repair proof obligations for ASMs with respect to these security contract requirements. In a first step towards this, the industrial use cases will be analysed for security threats from two different angles concerning secrets in the data and processes that are to be protected, and anticipated actions of potential attackers. Regarding secrets this will be formalised through static and dynamic constraints, for which subformulae are identified that by themselves do not contain any secrets. Regarding potential attacks, attacker models for each of the security constraints will be developed. In a second step, the one-step logic for reasoning about concurrent systems of ASM specifications will be used to formalise the security constraints. In addition, for each identified attack the anticipated approach of the attacker will be specified by a corresponding ASM.
\end{Task}


\begin{Task}
\TaskTitle{Dynamic Analysis of Security Contracts}
\TaskParticipant{UOD}{1}

\TaskStart{1}
\TaskEnd{27}
\TaskResults{%
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:dyncontracts}

In \theTask, we will focus on the dynamic analysis of security contracts for
vulnerabilities that cannot be formally verified without running the software component.
%cannot be proved by formal verification without running the software component.
\end{Task}



\begin{Task}
\TaskTitle{Static Analysis based Risk Assessment for Source Code Security Breaches}
\TaskParticipant{YAG}{1}

\TaskStart{1}
\TaskEnd{27}
\TaskResults{%
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:ContractsSastAssessment}

As a complementary approach to extend formal verification of security contracts, in \theTask, we will provide a novel way to assess the risk that a security contract is not met by an application. This will include:

\begin{itemize}
\item The parsing and analysis of the security contracts resulting from present \theWP / T4.XX and T4.YY
    \item Mapping of the security contracts with the potentially impacted source code
    \item Designing an interface between formal verification and static analysis to collect and include formally verified properties of the source code in the vulnerability assessment algorithms
    \item Explore overall risk assessment that a security contract is not met, integrating formally proven properties to static analysis outputs and machine learning detected uncertain security properties.
    \item Provide remediation proposals to fix vulnerabilities.
\end{itemize}

\end{Task}


\begin{Task}
\TaskTitle{Assessment of security requirements based on CVSS metrics}
\TaskParticipant{YAG}{1}

\TaskStart{1}
\TaskEnd{27}
\TaskResults{%
%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:RequirementsSastAssessment}

As another approach to extend formal verification of security contracts, in \theTask\ we can prototype a semi-automated assessment of functional security requirements, using the CVSS metrics such as confidentiality, integrity and availability.
We will develop a domain specific language to capture the functionalities description, allocate requirements and map with the source code. Each vulnerability which breaks a requirement will be identified and allocated decision making information for the user.
\end{Task}


\begin{WPDeliverables}
  \begin{compactitem}
    \item XX
%\item \ref{del:model1} (Month 10): Report on Initial Block-Diagram Modelling, Patterns and Code Synthesis
\end{compactitem}
\end{WPDeliverables}
\end{Workpackage}
