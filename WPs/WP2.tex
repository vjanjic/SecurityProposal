\addtocounter{wpno}{1}
\begin{Workpackage}{\thewpno}
\wplabel{wp:vulnerability}
\WPTitle{\wpname{\thewpno}}
\WPStart{Month 1}
\WPParticipant{IBM}{1}
\WPParticipant{SCCH}{1}
\WPParticipant{SOPRA}{1}
\WPParticipant{USTAN}{1}
\WPParticipant{YAG}{1}

\begin{WPObjectives}
The objectives of \theWP{} are to:
\begin{compactitem}
\item Develop static source code analysis methods to isolate the portions of the end user code that possibly contain security vulnerabilities.
\item Develop dynamic code analysis methods, based on symbolic execution and reinforcement learning that will profile the identified portions of the code to check for security vulnerabilities.
\item Augment the static and dynamic code analysis with runtime monitoring of the applications executed on distributed systems to identify the runtime security attacks on the end user applications.
\item Develop novel source-to-source code refactoring transformations to repair the vulnerabilities identified by the static and dynamic analysis.
\item Develop mechanisms for the runtime adaptation of the application for the situation where runtime security vulnerabilities have been identified or are suspected.
\end{compactitem}
\end{WPObjectives}

\begin{WPDescription}
The aim of \theWP{} is to develop foundational techniques for identifying and repairing security vulnerabilities in the C++ and Java code. In this workpackage we are focusing on generic techniques, whereas the WP3 deals with adaptation of these techniques to the problem of AI-based distributed data analytics. In order to ensure that we catch the widest possible range of security vulnerabilities, we will develop three layers of analysis. Initially we will perform static analysis (\ref{task:staticanalysis}) on the source code in order to identify the portions of code that are susceptible to vulnerabilities. We will then perform dynamic analysis based on symbolic execution (\ref{task:dynamicanalysis}) on the identified portions of code. These two phases will be augmented with runtime monitoring (\ref{task:runtime}) that will allow us to identify threats that can arise during the execution of the application and from dynamic unpredictable interactions, and would therefore be missed by static and dynamic analysis. The second part of the workpackage will be dedicated to developing \emph{self-healing} technology for repairing the vulnerabilities in the code. This will be done both statically, using formalised source-to-source code transformations ({\ref{task:statichealing}}) that will be implemented in the user interface in WP6, and at runtime, using runtime adaptation of the application and environment (\ref{task:runtimehealing}).
\end{WPDescription}

\begin{Task}
\TaskTitle{Static Source Code Analysis for Identifying Security Vulnerabilities}
\TaskParticipant{YAG}{1}
\TaskParticipant{IBM}{1}
\TaskParticipant{DEM}{1}
\TaskStart{1}
\TaskEnd{34}
\TaskResults{%
%%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:staticanalysis}
In this task we will develop technology for static analysis of the end user application source code to identify potential security vulnerabilities. We will build on the YAG-Suite capabilities and extend it with advanced vulnerability detection technology that will be based on SAST for Java and C/C++ code. Static analysis of the source code is relatively cheap in terms of computational complexity, but has a drawback that it produces potentially a significant number of false positives and duplicate warnings. Therefore, the output of this analysis will serve as an input to the dynamic vulnerability detection technology from Task \ref{task:dynamicanalysis}, where the portions of code where potential vulnerabilities are identified will be further analysed. The output of this task will also feed into Task \ref{task:frontend}, the user interface where the potential vulnerabilities will be displayed to the end users in a structured way.
\end{Task}

\begin{Task}
\TaskTitle{Symbolic Execution and Supervised Learning for Identifying Security Vulnerabilities}
\TaskParticipant{IBM}{1}
\TaskParticipant{SCCH}{1}
\TaskParticipant{DEM}{1}
\TaskParticipant{YAG}{1}
\TaskStart{1}
\TaskEnd{34}
\TaskResults{%
%%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:dynamicanalysis}
In this task we will develop technology for dynamic detection of vulnerabilities in the end user code. Focusing on the portions of user code identified by the technologies in Task \ref{task:staticanalysis}, we will apply IBM's ExpliSAT symbolic interpretation tool to verify the presence of security vulnerability patterns in the code. We plan to combine symbolic execution with white box fuzzing to find exploitable bugs. Combining static code analysis with dynamic detection will allow us to avoid the known problems of path explosion and memory growth when only symbolic execution is used, by allowing this technology to focus on relatively small portions of the user code and thus consistently making progress. To that end, the symbolic execution engine will query a fuzzer at run-time for information that would assist the symbolic interpreter make progress where it previously could not. In addition to symbolic execution, we will also develop technology for supervised machine learning post-processing of SAST warnings to further eliminate the possible false positives. 
\end{Task}

\begin{Task}
\TaskTitle{Runtime Analysis for Detecting Vulnerabilities}
\TaskParticipant{SCCH}{1}
\TaskParticipant{DEM}{1}
\TaskParticipant{YAG}{1}
\TaskParticipant{IBM}{1}
\TaskStart{1}
\TaskEnd{34}
\TaskResults{%
%%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:runtime}
In this task we will extend the vulnerability detection technology with the mechanisms that will monitor the runtime execution of the end user applications. This will allow us to identify vulnerabilities that arise from the unexpected interaction of data processing agents during computations and which could, therefore, not be identified by the static and dynamic analysis mechanisms. We will identify which data has to be collected at runtime in order to detect anomalies, i.e. when there are agents in the distributed parallel system that interact with the other agents in a malicious way. This requires the specification of monitoring agents. Based on this, we will then develop anomaly detection algorithms and their specification by further agents. The focus will be on discovery, whether the interaction sequence of any agent is in line with the specification of the system.
\end{Task}

\begin{Task}
\TaskTitle{Code Transformations for Self Healing}
\TaskParticipant{USTAN}{1}
\TaskStart{1}
\TaskEnd{34}
\TaskResults{%
%%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:statichealing}
\end{Task}

\begin{Task}
\TaskTitle{Runtime Adaptation for Self Healing}
\TaskParticipant{DEM}{1}
\TaskParticipant{SCCH}{1}
\TaskParticipant{IBM}{1}
\TaskStart{1}
\TaskEnd{34}
\TaskResults{%
%%\ref{del:model1}
}
\TaskHeader{}
\tasklabel{task:runtimehealing}
In this task we will develop mechanisms for runtime adaptation of the end user applications in the case when security violations are detected or suspected or when a suspicious agents has been detected that should be removed from the system. Both cases require the partial interrupt of the distributed application and/or infrastructure, the rollback to a consistent state and the restart after some modifications. We will also formulate the repairability proof obligations on the grounds of the research through which it will be specified, specifying after how many steps a secure situation is expected to be restored.
\end{Task}


%\begin{Task}
%%\TaskTitle{Parallel Computation and Control for High-Level Modelling Languages} % for Aerospace and Automotive Industries}
%\TaskTitle{Advanced Vulnerability Detection in Source Code}
%\TaskParticipant{UOD}{1}
%
%\TaskStart{1}
%\TaskEnd{34}
%\TaskResults{%
%%\ref{del:model1}
%}
%\TaskHeader{}
%\tasklabel{task:vulnerability}
%
%In \theTask, we will develop advanced vulnerability detection technology for C/C++ code. We plan to apply IBM's ExpliSAT symbolic interpretation tool to discover known security vulnerability patterns in C/C++code. Moreover, to avoid known limitations of the symbolic execution approach (e.g. path explosion, memory growth, etc.), we will develop a technology that leverages the combination of symbolic execution, static code analysis and white box fuzzing to find exploitable bugs. The idea is to perform symbolic execution as the main technique to discover vulnerabilities combined with tailored fuzzing techniques in specific small areas for the purpose of assisting the symbolic execution engine to consistently make progress. For that end, the symbolic execution engine will query a fuzzer at run-time for information that would assist the symbolic interpreter make progress where it previously couldn't. Static code analysis will assist to find suspected vulnerability locations prior to the invocation of the ExpliSAT tool and to control "hard to execute" use cases.
%
%This task will proceed in three phases ...
%
%\end{Task}
%
%\begin{Task}
%\TaskTitle{Vulnerability detection in Source Code based on static analysis and machine learning}
%\TaskParticipant{YAG}{1}
%
%\TaskStart{1}
%\TaskEnd{34}
%\TaskResults{%
%%\ref{del:model1}
%}
%\TaskHeader{}
%\tasklabel{task:sast}
%
%Starting from the YAG-Suite capabilities, in \theTask we will provide and improve the advanced vulnerability detection technology which is acheivable with SAST for JAVA and C/C++ source code. To avoid the recurring problem of false positives and duplicate warnings raising from scanning, the results generated by Static Analysis will be automatically qualified by a supervised machine learning based post-processing of SAST warnings. 
%The qualification process will support a risk based approach and provide decision making information for each warning such as its relevancy and its impact on CVSS metrics such as confidentiality, integrity, etc.
%Vulnerability detection will also include a remediation focus to provide options for fixing vulnerabilities and extract, when available, examples of correct source code as (and when) found in the application.
%The YAG-Suite will offer an API to partners so that they can query the SAST results they need.
%Static code analysis will assist to find suspected vulnerability locations prior to the invocation of the ExpliSAT tool and after, in order to refine ”hard to detect” vulnerabilities.
%
%
%\end{Task}
%
%\begin{Task}
%\TaskTitle{Anomaly Detection and Adaptation for Self-Healing}
%\TaskParticipant{SCCH}{1}
%
%\TaskStart{1}
%\TaskEnd{34}
%\TaskResults{%
%%\ref{del:model1}
%}
%\TaskHeader{}
%\tasklabel{task:scch}
%In a first step it will be analysed which run-time data has to be collected through monitoring machines that are needed for the detection of any anomaly, i.e. there are agents in the distributed concurrent system that interact with the other agents in a malicious way. This requires the specification of monitoring agents. The second step addresses the development of anomaly detection algorithms and their specification by further agents. The focus will be on discovery, whether the interaction sequence of any agent is in line with the specified system. The third step
%addresses adaptation algorithm in case a security violation is detected or a suspicious agents
%has been detected that should be removed from the system. Both cases require the partial interrupt of the distributed concurrent system, the rollback to a consistent state and the restart after some modifications. The last step undertaken in this task is the formulation of repairability proof obligations on the grounds of the research through which it will be specified, after how many steps a secure situation is expected to be restored.
%\end{Task}







\begin{WPDeliverables}
  \begin{compactitem}
    \item XX
%\item \ref{del:model1} (Month 10): Report on Initial Block-Diagram Modelling, Patterns and Code Synthesis
\end{compactitem}
\end{WPDeliverables}
\end{Workpackage}
